{
  "hash": "73fe3d168ce77a4e662d956f3e6f11db",
  "result": {
    "markdown": "---\ntitle: \"C++ Notes\"\ndescription: |\n  Distilled C++ Notes\nauthor:\n  - name: Bhanu Prasanna Koppolu\n    url: https://bhanuprasanna527.github.io/\n    orcid: 0000-0001-6050-2414\n    affiliation: M.Sc. Data Science at TU Dortmund\n    # affiliation-url: https://www.tu-dortmund.de/en/\ndate: 2023-10-25\ndate-modified: last-modified\n# bibliography: references.bib\ncitation: \n  url: https://bhanuprasanna527.github.io/notes/2023-10-25-C++/\ncategories: [Notes, C++, Challenge]\nimage: cpp.gif\ndraft: false\npage-layout: full\nformat:\n  html:\n    page-layout: full\n    theme: darkly\n    code-fold: true\n    code-tools:\n      source: false\n      toggle: true\n    code-summary: \"Show the code\"\n    highlight-style: dracula\n    css: styles.css\n    toc: true\n  pdf:\n    pdf-engine: xelatex\n    toc: true\n    documentclass: scrreprt\n    colorlinks: true\n    cite-method: biblatex\n    fig-align: center\n---\n\n# Day - 1\n\n## Time Complexity\n\n### Important Points\n\n- <u>***Definition***</u> - Time Complexity is the relationship about how the time will grow as the input grows.\n- Time Complexity != Total Time Taken by a Machine to execute.\n- There are mainly 4 points for Time Complexity:\n  1. Always look for the **Worst Case Time Complexity**.\n  2. Always look at the **Complexity for Large Data**.\n  3. Always **Ignore Constants**.\n  4. Always **Ignore Less Dominant Terms**. *From Point 2*\n\n## Akra-Bazzi Time Complexity Method\n\nIf the recurrence become more complex then finding the time complexity will become harder. So, Akra-Bazzi method is the easy and simple method to find the Time Complexity.\n\nThe method goes as follows:\n\nLet $p$ be the unique real number for which \n$$\\sum_{i=1}^{k} a_ib_i^p = 1$$\n\nThen,\n\n$$T(x) = \\Theta\\biggl(x^p + x^p \\int_1^x \\frac{g(u)}{u^{p+1}} du\\biggl)$$\n\n## Asymptotic Notation\n\nThe usage of Asymptotic Notation is for specifying and for the identification of the upper and lower bounds.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)}$$\n\nBelow are the Asymptotic Notations:\n\n### Big - $O$ Notation ($\\leq$  Upper Bound)\n\nThis is the Upper Bound and the complexity cannot go beyond this Upper Bound.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} < \\infty$$\n\n### Big - $\\Omega$ Notation ($\\geq$  Lower Bound)\n\nThis is the opposite of Big - $O$ Notation. This is the Lower Bound and the function complexity will atleast require Lower Bound complexity.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} > 0$$\n\n### Big - $\\Theta$ Notation (Average)\n\nThe Big - $\\Theta$ Notation was created when a function lies in both Upper Bound (Big - $O$) and Lower Bound (Big - $\\Omega$).\n\n$$0 < \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} < \\infty$$\n\n### Little - $o$ Notation ($<$ Upper Bound)\n\nThe Little - $o$ is same as Big - $O$ but it is slightly loose and strictly lesser than.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$\n\n### Little - $\\omega$ Notation ($>$  Lower Bound)\n\nThe Little - $\\omega$ is same as Big - $\\Omega$ but it is slightly loose and strictly greater than.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = \\infty$$\n\n## Space Complexity\n\n- Space Complexity is measured by combining the Input Space and the Auxilary Space. The same Asymptotic Notations discussed above are the ones used for Space Complexity.\n\n## Linear Recurrence (Homogenous and Non-Homogenous)\n\n- Resources Used:\n  - [Click Here!](https://www.youtube.com/watch?v=mV3wrLBbuuE)\n\nThis is the end of <u>***Day - 1***</u>.\n\n# Day - 2\n\n## Recursion\n\n### Important Points\n\n- Recursion helps in solving bigger/complex problems into smaller problems which can be solved in a simple way.\n- You can convert a Recursion solution into Iterative and Vice Versa.\n- Space Complexity is not constant due to Recursive Calls.\n\n### Types of Recurrence Relations\n\n1. Linear Recurrence Relation\n2. Divide & Conquer Recurrence Relation\n\n### How to understand & approach a problem?\n\n- Identify if you can break down problem into smaller problems.\n- Write the Recurrence Relations if needed.\n- Draw the Recursive Tree.\n- About the Tree:\n  - See the flow of functions, how they are getting into the stack.\n  - Identify and Focus on Left Tree Calls and Right Tree Calls.\n  - Draw the tree and pointers using Pen & Paper for better understanding. *\n  - Use a debugger to see the flow.\n- See how the values and what type of values are returned at each step. See where the function will come out. In the end you will come out of the main function.\n- Three Variables to concentrate on:\n  - Arguments\n  - Return Type\n  - Body of Function\n- Resources used:\n  - [Click Here!](https://www.youtube.com/watch?v=M2uO2nMT0Bk&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=23)\n\n## Math for DSA\n\n- Resources used:\n  - Math for DSA 1 - [Click Here!](https://www.youtube.com/watch?v=fzip9Aml6og&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=25)\n  - Math for DSA 2 - [Click Here!](https://www.youtube.com/watch?v=lmSpZ0bjCyQ&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=27)\n\nThis is the end of <u>***Day - 2***</u>.\n\n# Day - 3\n\n## C++ Start\n\n- I have solved 18 Hackerrank Problems in the C++ section. - [Click Here!](https://www.hackerrank.com/profile/bhanuprasanna81).\n\n# Day - 4\n\n- I have solved total of 28 Hackerrank Problems in the C++ section. <u>***I feel confident in C++.***</u> - [Click Here!](https://www.hackerrank.com/profile/bhanuprasanna81).\n\n## C++ from Book\n\n- C++ developed by Bjarne Stroustroup at Bell Labs (1979).\n\n### Learning Language Tradition - Hello, World! Program\n\n```cpp\n// Preprocessor Directive\n#include <iostream>\n\n// Start of the Program\nint main() {\n  // Tell the compiler what namespace to search in\n  using namespace std;\n\n  // Write to the screen using std::cout\n  cout << \"Hello, World!\" << endl;\n\n  // Return a value to the OS\n  return 0;\n}\n```\n\n# Day - 5\n\n- I have solved 5 LeetCode Questions using C++ in the Arrays Section. - [Click Here!](https://leetcode.com/bhanuprasanna527/).\n\n\n\n```{cpp filename=\"Two_Sum.cpp\"}\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int l = nums.size();\n        \n        for (int i = 0; i < l; i++) {\n            for (int j = 0; j < l && i != j; j ++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n\n        return {};\n    }\n};\n```\n\n",
    "supporting": [
      "index_files/figure-pdf"
    ],
    "filters": []
  }
}