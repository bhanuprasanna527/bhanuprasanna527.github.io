{
  "hash": "13dc7047d5c5a72bdd5292b6cb310b53",
  "result": {
    "markdown": "---\ntitle: \"C++ Notes\"\ndescription: |\n  Distilled C++ Notes\nauthor:\n  - name: Bhanu Prasanna Koppolu\n    url: https://bhanuprasanna527.github.io/\n    orcid: 0000-0001-6050-2414\n    affiliation: M.Sc. Data Science at TU Dortmund\n    # affiliation-url: https://www.tu-dortmund.de/en/\ndate: 2023-10-25\ndate-modified: last-modified\n# bibliography: references.bib\ncitation: \n  url: https://bhanuprasanna527.github.io/notes/2023-10-25-C++/\ncategories: [Notes, C++, Challenge]\nimage: cpp.gif\ndraft: false\npage-layout: full\nformat:\n  html:\n    page-layout: full\n    theme: darkly\n    code-fold: true\n    code-tools:\n      source: false\n      toggle: true\n    code-summary: \"Show the code\"\n    highlight-style: dracula\n    css: styles.css\n    toc: true\n  pdf:\n    pdf-engine: xelatex\n    toc: true\n    documentclass: scrreprt\n    colorlinks: true\n    cite-method: biblatex\n    fig-align: center\n---\n\n# Day - 1\n\n## Time Complexity\n\n### Important Points\n\n- <u>***Definition***</u> - Time Complexity is the relationship about how the time will grow as the input grows.\n- Time Complexity != Total Time Taken by a Machine to execute.\n- There are mainly 4 points for Time Complexity:\n  1. Always look for the **Worst Case Time Complexity**.\n  2. Always look at the **Complexity for Large Data**.\n  3. Always **Ignore Constants**.\n  4. Always **Ignore Less Dominant Terms**. *From Point 2*\n\n## Akra-Bazzi Time Complexity Method\n\nIf the recurrence become more complex then finding the time complexity will become harder. So, Akra-Bazzi method is the easy and simple method to find the Time Complexity.\n\nThe method goes as follows:\n\nLet $p$ be the unique real number for which \n$$\\sum_{i=1}^{k} a_ib_i^p = 1$$\n\nThen,\n\n$$T(x) = \\Theta\\biggl(x^p + x^p \\int_1^x \\frac{g(u)}{u^{p+1}} du\\biggl)$$\n\n## Asymptotic Notation\n\nThe usage of Asymptotic Notation is for specifying and for the identification of the upper and lower bounds.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)}$$\n\nBelow are the Asymptotic Notations:\n\n### Big - $O$ Notation ($\\leq$  Upper Bound)\n\nThis is the Upper Bound and the complexity cannot go beyond this Upper Bound.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} < \\infty$$\n\n### Big - $\\Omega$ Notation ($\\geq$  Lower Bound)\n\nThis is the opposite of Big - $O$ Notation. This is the Lower Bound and the function complexity will atleast require Lower Bound complexity.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} > 0$$\n\n### Big - $\\Theta$ Notation (Average)\n\nThe Big - $\\Theta$ Notation was created when a function lies in both Upper Bound (Big - $O$) and Lower Bound (Big - $\\Omega$).\n\n$$0 < \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} < \\infty$$\n\n### Little - $o$ Notation ($<$ Upper Bound)\n\nThe Little - $o$ is same as Big - $O$ but it is slightly loose and strictly lesser than.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$\n\n### Little - $\\omega$ Notation ($>$  Lower Bound)\n\nThe Little - $\\omega$ is same as Big - $\\Omega$ but it is slightly loose and strictly greater than.\n\n$$\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = \\infty$$\n\n## Space Complexity\n\n- Space Complexity is measured by combining the Input Space and the Auxilary Space. The same Asymptotic Notations discussed above are the ones used for Space Complexity.\n\n## Linear Recurrence (Homogenous and Non-Homogenous)\n\n- Resources Used:\n  - [Click Here!](https://www.youtube.com/watch?v=mV3wrLBbuuE)\n\nThis is the end of <u>***Day - 1***</u>.\n\n# Day - 2\n\n## Recursion\n\n### Important Points\n\n- Recursion helps in solving bigger/complex problems into smaller problems which can be solved in a simple way.\n- You can convert a Recursion solution into Iterative and Vice Versa.\n- Space Complexity is not constant due to Recursive Calls.\n\n### Types of Recurrence Relations\n\n1. Linear Recurrence Relation\n2. Divide & Conquer Recurrence Relation\n\n### How to understand & approach a problem?\n\n- Identify if you can break down problem into smaller problems.\n- Write the Recurrence Relations if needed.\n- Draw the Recursive Tree.\n- About the Tree:\n  - See the flow of functions, how they are getting into the stack.\n  - Identify and Focus on Left Tree Calls and Right Tree Calls.\n  - Draw the tree and pointers using Pen & Paper for better understanding. *\n  - Use a debugger to see the flow.\n- See how the values and what type of values are returned at each step. See where the function will come out. In the end you will come out of the main function.\n- Three Variables to concentrate on:\n  - Arguments\n  - Return Type\n  - Body of Function\n- Resources used:\n  - [Click Here!](https://www.youtube.com/watch?v=M2uO2nMT0Bk&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=23)\n\n## Math for DSA\n\n- Resources used:\n  - Math for DSA 1 - [Click Here!](https://www.youtube.com/watch?v=fzip9Aml6og&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=25)\n  - Math for DSA 2 - [Click Here!](https://www.youtube.com/watch?v=lmSpZ0bjCyQ&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=27)\n\nThis is the end of <u>***Day - 2***</u>.\n\n# Day - 3\n\n## C++ Start\n\n- I have solved 18 Hackerrank Problems in the C++ section. - [Click Here!](https://www.hackerrank.com/profile/bhanuprasanna81).\n\n# Day - 4\n\n- I have solved total of 28 Hackerrank Problems in the C++ section. <u>***I feel confident in C++.***</u> - [Click Here!](https://www.hackerrank.com/profile/bhanuprasanna81).\n\n## C++ from Book\n\n- C++ developed by Bjarne Stroustroup at Bell Labs (1979).\n\n### Learning Language Tradition - Hello, World! Program\n\n```cpp\n// Preprocessor Directive\n#include <iostream>\n\n// Start of the Program\nint main() {\n  // Tell the compiler what namespace to search in\n  using namespace std;\n\n  // Write to the screen using std::cout\n  cout << \"Hello, World!\" << endl;\n\n  // Return a value to the OS\n  return 0;\n}\n```\n\n# Day - 5\n\n- I have solved 5 LeetCode Questions using C++ in the Arrays Section. - [Click Here!](https://leetcode.com/bhanuprasanna527/).\n\n## LeetCode Questions & Answers\n\n### [Two Sum](https://leetcode.com/problems/two-sum/)\n\n```cpp\n//  Two_Sum.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int l = nums.size();\n        \n        for (int i = 0; i < l; i++) {\n            for (int j = 0; j < l && i != j; j ++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n\n        return {};\n    }\n};\n```\n\n### [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)\n\n```cpp\n//  Remove_Duplicates_from_Sorted_Array.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& v) {\n        int j = 1;\n\n        for (auto i = v.begin() + 1; i != v.end(); i++) {\n            if (*i != *(i - 1)) {\n                v[j] = *i;\n                j++;\n            }\n        }\n\n        return j;\n    }\n};\n```\n\n### [Remove Element](https://leetcode.com/problems/remove-element/description/)\n\n```cpp\n//  Remove_Element.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& v, int val) {\n        int j = 0;\n\n        for (auto i = v.begin(); i != v.end(); i++) {\n            if (*i != val) {\n                v[j] = *i;\n                j++;\n            }\n        }\n\n        return j;\n    }\n};\n```\n\n### [Search Insert Position](https://leetcode.com/problems/search-insert-position/description/)\n\n```cpp\n//  Search_Insert_Position.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        auto x = std::lower_bound(nums.begin(), nums.end(), target);\n\n        cout << (x - nums.begin()) << endl;\n\n        return x - nums.begin();\n    }\n};\n```\n\n### [Plus One](https://leetcode.com/problems/plus-one/description/)\n\n```cpp\n//  Plus_One.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n//  Not the Best Solution - Must Learn How to Optimize a Solution.\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& v) {\n        int c = 0, l = v.size();\n\n        for (int i = l-1; i >= 0; i--) {\n            if (i == l-1) {\n                if (v[i] == 9) {\n                    v[i] = 0;\n                    c = 1;\n                } else {\n                    v[i] += 1;\n                    return v;\n                }\n            } else {\n                if (v[i] == 9) {\n                    v[i] = 0;\n                    c = 1;\n                } else {\n                    v[i] += c;\n                    return v;\n                }\n            }\n        }\n\n        if (*v.begin() == 0) {\n            v.insert(v.begin(), 1);\n        }\n\n        return v;\n    }\n};\n```\n\n# Day - 6\n\n- I have solved 5 LeetCode Questions using C++ in the Arrays Section. - [Click Here!](https://leetcode.com/bhanuprasanna527/).\n\n## LeetCode Questions & Answers\n\n### Merge Sorted Array\n\n```cpp\n//  Merge_Sorted_Array.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n\n        while (j >= 0) {\n            if (i >= 0 && nums1[i] > nums2[j]) {\n                nums1[k] = nums1[i];\n                i--;\n            } else {\n                nums1[k] = nums2[j];\n                j--;\n            }\n            k--;\n        }\n    }\n};\n```\n\n### Pascal's Triangle\n\n```cpp\n//  Pascal's_Triangle.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> v;\n\n        for (int i = 0; i < numRows; i++) {\n            vector<int> x(i+1, 1);\n            for (int j = 1; j < i; j++) {\n                x[j] = v[i-1][j] + v[i-1][j-1];\n            }\n            v.push_back(x);\n        }\n        return v;\n    }\n};\n```\n\n### Pascal's Triangle 2\n\n```cpp\n//  Pascal's_Triange_2.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<vector<int>> v;\n        vector<int> xv;\n\n        for (int i = 0; i <= rowIndex; i++) {\n            vector<int> x(i+1, 1);\n\n            for (int j = 1; j < i; j++) {\n                x[j] = v[i-1][j] + v[i-1][j-1];\n            }\n            if (i == rowIndex) {\n                return x;\n            }\n\n            v.push_back(x);\n        }\n\n        return xv;\n    }\n};\n```\n\n### Best Time to Buy and Sell Stock\n\n```cpp\n// Best_Time_to_Buy_and_Sell_Stock.cpp\n// LeetCode - C++\n// Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int lsf = INT_MAX;\n        int op = 0;\n        int pist = 0;\n\n        for (int i = 0; i < prices.size(); i++) {\n            if (prices[i] < lsf) {\n                lsf = prices[i];\n            }\n            pist = prices[i] - lsf;\n            if (pist > op) {\n                op = pist;\n            }\n        }\n        return op;\n    }\n};\n```\n\n### Single Number\n\n```cpp\n// Single_Number.cpp\n// LeetCode - C++\n// Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n\n        for (auto x:nums) {\n            ans ^= x;\n        }\n\n        return ans;\n    }\n};\n```\n\n# Day - 7\n\n- I am going to implement Data Structures in C++.\n\n## Single Linked List\n\n```cpp\n//  Single_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass SLL : public Node {\n    Node* head;\n    \npublic:\n    SLL () {\n        head = nullptr;\n    }\n    \n    // Insert Data at the Front of SLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of SLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of SLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of SLL\n    void delete_front();\n    \n    // Delete Data from the Back of SLL\n    void delete_back();\n    \n    // Delete Data from the Middle of SLL\n    void del(int);\n    \n    // Length of the SLL\n    int length();\n    \n    // Print SLL\n    void printll();\n    \n};\n\n/* Delete Functions for Single Linked List */\n\nvoid SLL::delete_front () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"There are no element in the SLL to delete!\" << endl;\n        return;\n    }\n    \n    head = head->next;\n}\n\nvoid SLL::delete_back () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"There are no element in the SLL to delete!\" << endl;\n        return;\n    }\n    \n    while (t->next->next != nullptr) {\n        t = t->next;\n    }\n    t->next = nullptr;\n}\n\nvoid SLL::del(int pos) {\n    Node *x = head;\n    Node *y = head->next;\n    \n    if (x == nullptr) {\n        cout << \"There are no element in the SLL to delete!\" << endl;\n        return;\n    }\n    \n    for (int i = 0; i < pos - 2; i++) {\n        x = x->next;\n        y = y->next;\n    }\n    x->next = y->next;\n}\n\n/* Insertion Functions for Single Linked List */\n\nvoid SLL::insert_front (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    t->next = head;\n    \n    head = t;\n    \n}\n\nvoid SLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    Node *x = head;\n    \n    while (x->next != nullptr) {\n        x = x->next;\n    }\n    x->next = t;\n}\n\nvoid SLL::insert (int d, int pos) {\n    \n    if (pos > SLL::length()) {\n        SLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        SLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head->next;\n    \n    for (int i = 0; i < pos - 2; i++) {\n        x = x->next;\n        y = y->next;\n    }\n    \n    t->next = y;\n    x->next = t;\n}\n\n/* Length of Single Linked List */\n\nint SLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        t = t->next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Single Linked List */\n\nvoid SLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"Linked List is Empty\" << endl;\n        return;\n    }\n    \n    while (t != nullptr) {\n        if (t->next == nullptr) {\n            cout << t->data << endl;\n        } else {\n            cout << t->data << \" -> \";\n        }\n        t = t->next;\n    }\n}\n\nint main () {\n    SLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout << \"Elements of Linked List are:\" << endl;\n    \n    l.printll();\n    \n    cout << endl << \"Count: \" << l.length() << endl;\n    \n    return 0;\n}\n```\n\n## Double Linked List\n\n\n\n```{cpp}\n//  Double_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n        prev = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DLL : public Node {\n    Node* head;\n    \npublic:\n    DLL () {\n        head = nullptr;\n    }\n    \n    // Insert Data at the Front of DLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of DLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of DLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of DLL\n    void delete_front();\n    \n    // Delete Data from the Back of DLL\n    void delete_back();\n    \n    // Delete Data from the Middle of DLL\n    void del(int);\n    \n    // Length of the DLL\n    int length();\n    \n    // Print DLL\n    void printll();\n    \n};\n\n/* Delete Functions for Double Linked List */\n\nvoid DLL::delete_front () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"There are no element in the DLL to delete!\" << endl;\n        return;\n    }\n    \n    head = head->next;\n    head->prev = nullptr;\n}\n\nvoid DLL::delete_back () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"There are no element in the DLL to delete!\" << endl;\n        return;\n    }\n    \n    while (t->next->next != nullptr) {\n        t = t->next;\n    }\n    t->next = nullptr;\n}\n\nvoid DLL::del(int pos) {\n    Node *x = head;\n    Node *y = head->next;\n    \n    if (x == nullptr) {\n        cout << \"There are no element in the DLL to delete!\" << endl;\n        return;\n    }\n    \n    for (int i = 0; i < pos - 2; i++) {\n        x = x->next;\n        y = y->next;\n    }\n    y->next->prev = x;\n    x->next = y->next;\n}\n\n/* Insertion Functions for Double Linked List */\n\nvoid DLL::insert_front (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    t->next = head;\n    head->prev = t;\n    \n    head = t;\n    \n}\n\nvoid DLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    Node *x = head;\n    \n    while (x->next != nullptr) {\n        x = x->next;\n    }\n    x->next = t;\n    t->prev = x;\n}\n\nvoid DLL::insert (int d, int pos) {\n    \n    if (pos > DLL::length()) {\n        DLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        DLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head->next;\n    \n    for (int i = 0; i < pos - 2; i++) {\n        x = x->next;\n        y = y->next;\n    }\n    \n    t->next = y;\n    y->prev = t;\n    t->prev = x;\n    x->next = t;\n}\n\n/* Length of Double Linked List */\n\nint DLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        t = t->next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Double Linked List */\n\nvoid DLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"Linked List is Empty\" << endl;\n        return;\n    }\n    \n    while (t != nullptr) {\n        if (t->next == nullptr) {\n            cout << t->data << endl;\n        } else {\n            cout << t->data << \" -> \";\n        }\n        t = t->next;\n    }\n}\n\nint main () {\n    DLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout << \"Elements of Linked List are:\" << endl;\n    \n    l.printll();\n    \n    cout << endl << \"Count: \" << l.length() << endl;\n    \n    return 0;\n}\n```\n\n\n\n## Circular Linked List\n\n```cpp\n//  Circular_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass CLL : public Node {\n    Node* head;\n    Node* last;\n    \npublic:\n    CLL () {\n        head = nullptr;\n        last = nullptr;\n    }\n    \n    // Insert Data at the Front of CLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of CLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of CLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of CLL\n    void delete_front();\n    \n    // Delete Data from the Back of CLL\n    void delete_back();\n    \n    // Delete Data from the Middle of CLL\n    void del(int);\n    \n    // Length of the CLL\n    int length();\n    \n    // Print CLL\n    void printll();\n};\n\n\n/* Delete Functions for Circular Linked List */\n\nvoid CLL::delete_front() {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"There are no element in the CLL to delete!\" << endl;\n    }\n    \n    head = head->next;\n    last->next = head;\n}\n\nvoid CLL::delete_back() {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"There are no element in the CLL to delete!\" << endl;\n    }\n    \n    if (t->next == head) {\n        head = nullptr;\n        last = nullptr;\n    }\n    \n    while (t->next->next != head) {\n        t = t->next;\n    }\n    \n    last = t;\n    \n    last->next = head;\n}\n\nvoid CLL::del(int pos) {\n    Node *x = head;\n    Node *y = head->next;\n    \n    if (x == nullptr) {\n        cout << \"There are no element in the CLL to delete!\" << endl;\n    }\n    \n    if (pos == CLL::length()) {\n        CLL::delete_back();\n    }\n    \n    for (int i = 0; i < pos - 2; i++) {\n        x = x->next;\n        y = y->next;\n    }\n    \n    x->next = y->next;\n}\n\n/* Insertion Functions for Circular Linked List */\n\nvoid CLL::insert_front(int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        last = t;\n        last->next = head;\n        return;\n    }\n    \n    t->next = head;\n    head = t;\n    last->next = head;\n}\n\nvoid CLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        insert_front(d);\n        return;\n    }\n    \n    t->next = head;\n    last->next = t;\n    last = t;\n}\n\nvoid CLL::insert (int d, int pos) {\n    if (pos > CLL::length()) {\n        CLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        CLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head->next;\n    \n    for (int i = 0; i < pos - 2; i++) {\n        x = x->next;\n        y = y->next;\n    }\n    \n    t->next = y;\n    x->next = t;\n}\n\n/* Length of Double Linked List */\n\nint CLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    if (t == nullptr) {\n        return 0;\n    }\n    \n    c++;\n    t = t->next;\n    \n    while (t != head) {\n        t = t->next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Double Linked List */\n\nvoid CLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout << \"Linked List is Empty\" << endl;\n        return;\n    }\n    \n    cout << t->data << \"-> \";\n    t = t->next;\n    \n    while (t != head) {\n        if (t->next == head) {\n            cout << t->data << endl;\n        } else {\n            cout << t->data << \" -> \";\n        }\n        t = t->next;\n    }\n}\n\n\nint main () {\n    CLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout << \"Elements of Linked List are:\" << endl;\n    \n    l.printll();\n    \n    cout << endl << \"Count: \" << l.length() << endl;\n    \n    return 0;\n}\n```\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}