[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html",
    "href": "challenges/2024-02-09-Blind_75/index.html",
    "title": "Blind 75",
    "section": "",
    "text": "I want to improve my problem solving skills. I am starting with Blind 75.\nLanguage Used -  C++\n\n\n\n\nThe optimal solution uses a Unordered Map which is internally built using Hash Table concepts.\nUsage of Hash Table enables the least cost of operations like search, delete, and insert.\n\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {\n        unordered_map&lt;int, int&gt; s;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            int com = target - nums[i];\n            if (s.find(com) != s.end()) {\n                return {s[com], i};\n            }\n            s.insert({nums[i], i});\n        }\n        return {};\n    }\n};\n\n\n\n\n\n\nThe optimal solution uses a Unordered Set which is internally built using Hash Table concepts.\nUsage of Hash Table enables the least cost of operations like search, delete, and insert.\n\n\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector&lt;int&gt;& nums) {\n        unordered_set&lt;int&gt; us;\n\n        for (int i : nums) {\n            if (us.find(i) != us.end()) {\n                return true;\n            }\n            us.insert(i);\n        }\n\n        return false;\n    }\n};\n\n\n\n\n\n\nThe optimal solution is to count the number of characters in each string for the 26 alphabets.\n\n\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n\n        int c1[26] = {0};\n        int c2[26] = {0};\n\n        for (int i = 0; i &lt; s.size(); i++) {\n            c1[(s[i] - 97)]++;\n            c2[(t[i] - 97)]++;\n        }\n\n        for (int i = 0; i &lt; 26; i++) {\n            if (c1[i] != c2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\n\n\n\n\n\nThe optimal solution uses the same 26 alphabet count method but additionally uses a map to store the same type anagrams.\n\n\n\nclass Solution {\nprivate:\n    string getKey (string str) {\n        vector&lt;int&gt; v(26,0);\n\n        for (int i = 0; i &lt; str.size(); i++) {\n            v[str[i] - 'a']++;\n        }\n\n        string s = \"\";\n\n        for (int i = 0; i &lt; 26; i++) {\n            s += '#' + to_string(v[i]);\n        }\n\n        return s;\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;& strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; um;\n\n        for (int i = 0; i &lt; strs.size(); i++) {\n            string k = getKey(strs[i]);\n            um[k].push_back(strs[i]);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; v;\n\n        for (auto i = um.begin(); i != um.end(); i++) {\n            v.push_back(i-&gt;second);\n        }\n\n        return v;\n    }\n};\n\n\n\n\n\n\nUsage of modified Bucket Sort approach which provides this optimal solution. This solution can also be done using Max Heap.\n\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;& nums, int k) {\n        unordered_map&lt;int, int&gt; um;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            um[nums[i]]++;\n        }\n\n        vector&lt;vector&lt;int&gt;&gt; v(nums.size() + 1);\n        for (auto it = um.begin(); it != um.end(); it++) {\n            v[it-&gt;second].push_back(it-&gt;first);\n        }\n\n        vector&lt;int&gt; result;\n\n        for (int i = nums.size(); i &gt;= 0; i--) {\n            if (result.size() &gt;= k) {\n                return result;\n            }\n            if (v[i].size() != 0) {\n                result.insert(result.end(), v[i].begin(), v[i].end());\n            }\n        }\n\n        return {};\n    }\n};\n\n\n\n\n\n\nThe optimal solution is using a prefix and a postfix to parse through the array from both sides and multiplying.\n\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;& nums) {\n        vector&lt;int&gt; result(nums.size(), 1);\n        int pre = 1;\n        int post = 1;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            result[i] = result[i] * pre;\n            pre = pre * nums[i];\n        }\n\n        for (int i = nums.size() - 1; i &gt;= 0; i--) {\n            result[i] = result[i] * post;\n            post = post * nums[i];\n        }\n\n        return result;\n    }\n};"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html#two-sum---easy",
    "href": "challenges/2024-02-09-Blind_75/index.html#two-sum---easy",
    "title": "Blind 75",
    "section": "",
    "text": "The optimal solution uses a Unordered Map which is internally built using Hash Table concepts.\nUsage of Hash Table enables the least cost of operations like search, delete, and insert.\n\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {\n        unordered_map&lt;int, int&gt; s;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            int com = target - nums[i];\n            if (s.find(com) != s.end()) {\n                return {s[com], i};\n            }\n            s.insert({nums[i], i});\n        }\n        return {};\n    }\n};"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html#contains-duplicate---easy",
    "href": "challenges/2024-02-09-Blind_75/index.html#contains-duplicate---easy",
    "title": "Blind 75",
    "section": "",
    "text": "The optimal solution uses a Unordered Set which is internally built using Hash Table concepts.\nUsage of Hash Table enables the least cost of operations like search, delete, and insert.\n\n\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector&lt;int&gt;& nums) {\n        unordered_set&lt;int&gt; us;\n\n        for (int i : nums) {\n            if (us.find(i) != us.end()) {\n                return true;\n            }\n            us.insert(i);\n        }\n\n        return false;\n    }\n};"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html#valid-anagram---easy",
    "href": "challenges/2024-02-09-Blind_75/index.html#valid-anagram---easy",
    "title": "Blind 75",
    "section": "",
    "text": "The optimal solution is to count the number of characters in each string for the 26 alphabets.\n\n\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n\n        int c1[26] = {0};\n        int c2[26] = {0};\n\n        for (int i = 0; i &lt; s.size(); i++) {\n            c1[(s[i] - 97)]++;\n            c2[(t[i] - 97)]++;\n        }\n\n        for (int i = 0; i &lt; 26; i++) {\n            if (c1[i] != c2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html#group-anagrams---medium",
    "href": "challenges/2024-02-09-Blind_75/index.html#group-anagrams---medium",
    "title": "Blind 75",
    "section": "",
    "text": "The optimal solution uses the same 26 alphabet count method but additionally uses a map to store the same type anagrams.\n\n\n\nclass Solution {\nprivate:\n    string getKey (string str) {\n        vector&lt;int&gt; v(26,0);\n\n        for (int i = 0; i &lt; str.size(); i++) {\n            v[str[i] - 'a']++;\n        }\n\n        string s = \"\";\n\n        for (int i = 0; i &lt; 26; i++) {\n            s += '#' + to_string(v[i]);\n        }\n\n        return s;\n    }\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;& strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; um;\n\n        for (int i = 0; i &lt; strs.size(); i++) {\n            string k = getKey(strs[i]);\n            um[k].push_back(strs[i]);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; v;\n\n        for (auto i = um.begin(); i != um.end(); i++) {\n            v.push_back(i-&gt;second);\n        }\n\n        return v;\n    }\n};"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html#top-k-frequent-elements---medium",
    "href": "challenges/2024-02-09-Blind_75/index.html#top-k-frequent-elements---medium",
    "title": "Blind 75",
    "section": "",
    "text": "Usage of modified Bucket Sort approach which provides this optimal solution. This solution can also be done using Max Heap.\n\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;& nums, int k) {\n        unordered_map&lt;int, int&gt; um;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            um[nums[i]]++;\n        }\n\n        vector&lt;vector&lt;int&gt;&gt; v(nums.size() + 1);\n        for (auto it = um.begin(); it != um.end(); it++) {\n            v[it-&gt;second].push_back(it-&gt;first);\n        }\n\n        vector&lt;int&gt; result;\n\n        for (int i = nums.size(); i &gt;= 0; i--) {\n            if (result.size() &gt;= k) {\n                return result;\n            }\n            if (v[i].size() != 0) {\n                result.insert(result.end(), v[i].begin(), v[i].end());\n            }\n        }\n\n        return {};\n    }\n};"
  },
  {
    "objectID": "challenges/2024-02-09-Blind_75/index.html#product-of-array-except-itself---medium",
    "href": "challenges/2024-02-09-Blind_75/index.html#product-of-array-except-itself---medium",
    "title": "Blind 75",
    "section": "",
    "text": "The optimal solution is using a prefix and a postfix to parse through the array from both sides and multiplying.\n\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;& nums) {\n        vector&lt;int&gt; result(nums.size(), 1);\n        int pre = 1;\n        int post = 1;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            result[i] = result[i] * pre;\n            pre = pre * nums[i];\n        }\n\n        for (int i = nums.size() - 1; i &gt;= 0; i--) {\n            result[i] = result[i] * post;\n            post = post * nums[i];\n        }\n\n        return result;\n    }\n};"
  },
  {
    "objectID": "challenges.html",
    "href": "challenges.html",
    "title": "Challenges",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nBlind 75\n\n\n\n\n\n\nBlind75\n\n\nNeetCode\n\n\nLeetCode\n\n\nCoding\n\n\nNotes\n\n\nC++\n\n\nChallenge\n\n\n\nLearning by Solving Blind 75 \n\n\n\n\n\nFeb 9, 2024\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bhanu Prasanna",
    "section": "",
    "text": "M.Sc. Data Science at TU Dortmund\n\n\n\nIt’s Black. 👁️👁️ are Safe"
  }
]