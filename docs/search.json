[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nSetup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes\n\n\n\n\n\n\n\nFirst\n\n\nBlog\n\n\nTest\n\n\n\n\nInstalling TensorFlow, PyTorch, and other Libraries on Mac\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html",
    "href": "notes/2023-10-25-C++/index.html",
    "title": "C++ Notes",
    "section": "",
    "text": "Definition - Time Complexity is the relationship about how the time will grow as the input grows.\nTime Complexity != Total Time Taken by a Machine to execute.\nThere are mainly 4 points for Time Complexity:\n\nAlways look for the Worst Case Time Complexity.\nAlways look at the Complexity for Large Data.\nAlways Ignore Constants.\nAlways Ignore Less Dominant Terms. From Point 2\n\n\n\n\n\n\nIf the recurrence become more complex then finding the time complexity will become harder. So, Akra-Bazzi method is the easy and simple method to find the Time Complexity.\nThe method goes as follows:\nLet \\(p\\) be the unique real number for which \\[\\sum_{i=1}^{k} a_ib_i^p = 1\\]\nThen,\n\\[T(x) = \\Theta\\biggl(x^p + x^p \\int_1^x \\frac{g(u)}{u^{p+1}} du\\biggl)\\]\n\n\n\nThe usage of Asymptotic Notation is for specifying and for the identification of the upper and lower bounds.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)}\\]\nBelow are the Asymptotic Notations:\n\n\nThis is the Upper Bound and the complexity cannot go beyond this Upper Bound.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThis is the opposite of Big - \\(O\\) Notation. This is the Lower Bound and the function complexity will atleast require Lower Bound complexity.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &gt; 0\\]\n\n\n\nThe Big - \\(\\Theta\\) Notation was created when a function lies in both Upper Bound (Big - \\(O\\)) and Lower Bound (Big - \\(\\Omega\\)).\n\\[0 &lt; \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThe Little - \\(o\\) is same as Big - \\(O\\) but it is slightly loose and strictly lesser than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0\\]\n\n\n\nThe Little - \\(\\omega\\) is same as Big - \\(\\Omega\\) but it is slightly loose and strictly greater than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\]\n\n\n\n\n\nSpace Complexity is measured by combining the Input Space and the Auxilary Space. The same Asymptotic Notations discussed above are the ones used for Space Complexity.\n\n\n\n\n\nResources Used:\n\nClick Here!\n\n\nThis is the end of Day - 1."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#time-complexity",
    "href": "notes/2023-10-25-C++/index.html#time-complexity",
    "title": "C++ Notes",
    "section": "",
    "text": "Definition - Time Complexity is the relationship about how the time will grow as the input grows.\nTime Complexity != Total Time Taken by a Machine to execute.\nThere are mainly 4 points for Time Complexity:\n\nAlways look for the Worst Case Time Complexity.\nAlways look at the Complexity for Large Data.\nAlways Ignore Constants.\nAlways Ignore Less Dominant Terms. From Point 2"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#akra-bazzi-time-complexity-method",
    "href": "notes/2023-10-25-C++/index.html#akra-bazzi-time-complexity-method",
    "title": "C++ Notes",
    "section": "",
    "text": "If the recurrence become more complex then finding the time complexity will become harder. So, Akra-Bazzi method is the easy and simple method to find the Time Complexity.\nThe method goes as follows:\nLet \\(p\\) be the unique real number for which \\[\\sum_{i=1}^{k} a_ib_i^p = 1\\]\nThen,\n\\[T(x) = \\Theta\\biggl(x^p + x^p \\int_1^x \\frac{g(u)}{u^{p+1}} du\\biggl)\\]"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#asymptotic-notation",
    "href": "notes/2023-10-25-C++/index.html#asymptotic-notation",
    "title": "C++ Notes",
    "section": "",
    "text": "The usage of Asymptotic Notation is for specifying and for the identification of the upper and lower bounds.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)}\\]\nBelow are the Asymptotic Notations:\n\n\nThis is the Upper Bound and the complexity cannot go beyond this Upper Bound.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThis is the opposite of Big - \\(O\\) Notation. This is the Lower Bound and the function complexity will atleast require Lower Bound complexity.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &gt; 0\\]\n\n\n\nThe Big - \\(\\Theta\\) Notation was created when a function lies in both Upper Bound (Big - \\(O\\)) and Lower Bound (Big - \\(\\Omega\\)).\n\\[0 &lt; \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThe Little - \\(o\\) is same as Big - \\(O\\) but it is slightly loose and strictly lesser than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0\\]\n\n\n\nThe Little - \\(\\omega\\) is same as Big - \\(\\Omega\\) but it is slightly loose and strictly greater than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\]"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#space-complexity",
    "href": "notes/2023-10-25-C++/index.html#space-complexity",
    "title": "C++ Notes",
    "section": "",
    "text": "Space Complexity is measured by combining the Input Space and the Auxilary Space. The same Asymptotic Notations discussed above are the ones used for Space Complexity."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#linear-recurrence-homogenous-and-non-homogenous",
    "href": "notes/2023-10-25-C++/index.html#linear-recurrence-homogenous-and-non-homogenous",
    "title": "C++ Notes",
    "section": "",
    "text": "Resources Used:\n\nClick Here!\n\n\nThis is the end of Day - 1."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#recursion",
    "href": "notes/2023-10-25-C++/index.html#recursion",
    "title": "C++ Notes",
    "section": "Recursion",
    "text": "Recursion\n\nImportant Points\n\nRecursion helps in solving bigger/complex problems into smaller problems which can be solved in a simple way.\nYou can convert a Recursion solution into Iterative and Vice Versa.\nSpace Complexity is not constant due to Recursive Calls.\n\n\n\nTypes of Recurrence Relations\n\nLinear Recurrence Relation\nDivide & Conquer Recurrence Relation\n\n\n\nHow to understand & approach a problem?\n\nIdentify if you can break down problem into smaller problems.\nWrite the Recurrence Relations if needed.\nDraw the Recursive Tree.\nAbout the Tree:\n\nSee the flow of functions, how they are getting into the stack.\nIdentify and Focus on Left Tree Calls and Right Tree Calls.\nDraw the tree and pointers using Pen & Paper for better understanding. *\nUse a debugger to see the flow.\n\nSee how the values and what type of values are returned at each step. See where the function will come out. In the end you will come out of the main function.\nThree Variables to concentrate on:\n\nArguments\nReturn Type\nBody of Function\n\nResources used:\n\nClick Here!"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#math-for-dsa",
    "href": "notes/2023-10-25-C++/index.html#math-for-dsa",
    "title": "C++ Notes",
    "section": "Math for DSA",
    "text": "Math for DSA\n\nResources used:\n\nMath for DSA 1 - Click Here!\nMath for DSA 2 - Click Here!\n\n\nThis is the end of Day - 2."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#c-start",
    "href": "notes/2023-10-25-C++/index.html#c-start",
    "title": "C++ Notes",
    "section": "C++ Start",
    "text": "C++ Start\n\nI have solved 18 Hackerrank Problems in the C++ section. - Click Here!."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#c-from-book",
    "href": "notes/2023-10-25-C++/index.html#c-from-book",
    "title": "C++ Notes",
    "section": "C++ from Book",
    "text": "C++ from Book\n\nC++ developed by Bjarne Stroustroup at Bell Labs (1979).\n\n\nLearning Language Tradition - Hello, World! Program\n// Preprocessor Directive\n#include &lt;iostream&gt;\n\n// Start of the Program\nint main() {\n  // Tell the compiler what namespace to search in\n  using namespace std;\n\n  // Write to the screen using std::cout\n  cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n  // Return a value to the OS\n  return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#leetcode-questions-answers",
    "href": "notes/2023-10-25-C++/index.html#leetcode-questions-answers",
    "title": "C++ Notes",
    "section": "LeetCode Questions & Answers",
    "text": "LeetCode Questions & Answers\n\nTwo Sum\n//  Two_Sum.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {\n        int l = nums.size();\n        \n        for (int i = 0; i &lt; l; i++) {\n            for (int j = 0; j &lt; l && i != j; j ++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n\n        return {};\n    }\n};\n\n\nRemove Duplicates from Sorted Array\n//  Remove_Duplicates_from_Sorted_Array.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;& v) {\n        int j = 1;\n\n        for (auto i = v.begin() + 1; i != v.end(); i++) {\n            if (*i != *(i - 1)) {\n                v[j] = *i;\n                j++;\n            }\n        }\n\n        return j;\n    }\n};\n\n\nRemove Element\n//  Remove_Element.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int removeElement(vector&lt;int&gt;& v, int val) {\n        int j = 0;\n\n        for (auto i = v.begin(); i != v.end(); i++) {\n            if (*i != val) {\n                v[j] = *i;\n                j++;\n            }\n        }\n\n        return j;\n    }\n};\n\n\nSearch Insert Position\n//  Search_Insert_Position.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int searchInsert(vector&lt;int&gt;& nums, int target) {\n        auto x = std::lower_bound(nums.begin(), nums.end(), target);\n\n        cout &lt;&lt; (x - nums.begin()) &lt;&lt; endl;\n\n        return x - nums.begin();\n    }\n};\n\n\nPlus One\n//  Plus_One.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n//  Not the Best Solution - Must Learn How to Optimize a Solution.\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;& v) {\n        int c = 0, l = v.size();\n\n        for (int i = l-1; i &gt;= 0; i--) {\n            if (i == l-1) {\n                if (v[i] == 9) {\n                    v[i] = 0;\n                    c = 1;\n                } else {\n                    v[i] += 1;\n                    return v;\n                }\n            } else {\n                if (v[i] == 9) {\n                    v[i] = 0;\n                    c = 1;\n                } else {\n                    v[i] += c;\n                    return v;\n                }\n            }\n        }\n\n        if (*v.begin() == 0) {\n            v.insert(v.begin(), 1);\n        }\n\n        return v;\n    }\n};"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#leetcode-questions-answers-1",
    "href": "notes/2023-10-25-C++/index.html#leetcode-questions-answers-1",
    "title": "C++ Notes",
    "section": "LeetCode Questions & Answers",
    "text": "LeetCode Questions & Answers\n\nMerge Sorted Array\n//  Merge_Sorted_Array.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    void merge(vector&lt;int&gt;& nums1, int m, vector&lt;int&gt;& nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n\n        while (j &gt;= 0) {\n            if (i &gt;= 0 && nums1[i] &gt; nums2[j]) {\n                nums1[k] = nums1[i];\n                i--;\n            } else {\n                nums1[k] = nums2[j];\n                j--;\n            }\n            k--;\n        }\n    }\n};\n\n\nPascal‚Äôs Triangle\n//  Pascal's_Triangle.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {\n        vector&lt;vector&lt;int&gt;&gt; v;\n\n        for (int i = 0; i &lt; numRows; i++) {\n            vector&lt;int&gt; x(i+1, 1);\n            for (int j = 1; j &lt; i; j++) {\n                x[j] = v[i-1][j] + v[i-1][j-1];\n            }\n            v.push_back(x);\n        }\n        return v;\n    }\n};\n\n\nPascal‚Äôs Triangle 2\n//  Pascal's_Triange_2.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector&lt;int&gt; getRow(int rowIndex) {\n        vector&lt;vector&lt;int&gt;&gt; v;\n        vector&lt;int&gt; xv;\n\n        for (int i = 0; i &lt;= rowIndex; i++) {\n            vector&lt;int&gt; x(i+1, 1);\n\n            for (int j = 1; j &lt; i; j++) {\n                x[j] = v[i-1][j] + v[i-1][j-1];\n            }\n            if (i == rowIndex) {\n                return x;\n            }\n\n            v.push_back(x);\n        }\n\n        return xv;\n    }\n};\n\n\nBest Time to Buy and Sell Stock\n// Best_Time_to_Buy_and_Sell_Stock.cpp\n// LeetCode - C++\n// Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;& prices) {\n        int lsf = INT_MAX;\n        int op = 0;\n        int pist = 0;\n\n        for (int i = 0; i &lt; prices.size(); i++) {\n            if (prices[i] &lt; lsf) {\n                lsf = prices[i];\n            }\n            pist = prices[i] - lsf;\n            if (pist &gt; op) {\n                op = pist;\n            }\n        }\n        return op;\n    }\n};\n\n\nSingle Number\n// Single_Number.cpp\n// LeetCode - C++\n// Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;& nums) {\n        int ans = 0;\n\n        for (auto x:nums) {\n            ans ^= x;\n        }\n\n        return ans;\n    }\n};"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#single-linked-list",
    "href": "notes/2023-10-25-C++/index.html#single-linked-list",
    "title": "C++ Notes",
    "section": "Single Linked List",
    "text": "Single Linked List\n//  Single_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass SLL : public Node {\n    Node* head;\n    \npublic:\n    SLL () {\n        head = nullptr;\n    }\n    \n    // Insert Data at the Front of SLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of SLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of SLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of SLL\n    void delete_front();\n    \n    // Delete Data from the Back of SLL\n    void delete_back();\n    \n    // Delete Data from the Middle of SLL\n    void del(int);\n    \n    // Length of the SLL\n    int length();\n    \n    // Print SLL\n    void printll();\n    \n};\n\n/* Delete Functions for Single Linked List */\n\nvoid SLL::delete_front () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the SLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    head = head-&gt;next;\n}\n\nvoid SLL::delete_back () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the SLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t-&gt;next-&gt;next != nullptr) {\n        t = t-&gt;next;\n    }\n    t-&gt;next = nullptr;\n}\n\nvoid SLL::del(int pos) {\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    if (x == nullptr) {\n        cout &lt;&lt; \"There are no element in the SLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    x-&gt;next = y-&gt;next;\n}\n\n/* Insertion Functions for Single Linked List */\n\nvoid SLL::insert_front (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    t-&gt;next = head;\n    \n    head = t;\n    \n}\n\nvoid SLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    Node *x = head;\n    \n    while (x-&gt;next != nullptr) {\n        x = x-&gt;next;\n    }\n    x-&gt;next = t;\n}\n\nvoid SLL::insert (int d, int pos) {\n    \n    if (pos &gt; SLL::length()) {\n        SLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        SLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    t-&gt;next = y;\n    x-&gt;next = t;\n}\n\n/* Length of Single Linked List */\n\nint SLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        t = t-&gt;next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Single Linked List */\n\nvoid SLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"Linked List is Empty\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t != nullptr) {\n        if (t-&gt;next == nullptr) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\nint main () {\n    SLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout &lt;&lt; \"Elements of Linked List are:\" &lt;&lt; endl;\n    \n    l.printll();\n    \n    cout &lt;&lt; endl &lt;&lt; \"Count: \" &lt;&lt; l.length() &lt;&lt; endl;\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#double-linked-list",
    "href": "notes/2023-10-25-C++/index.html#double-linked-list",
    "title": "C++ Notes",
    "section": "Double Linked List",
    "text": "Double Linked List\n//  Double_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n        prev = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DLL : public Node {\n    Node* head;\n    \npublic:\n    DLL () {\n        head = nullptr;\n    }\n    \n    // Insert Data at the Front of DLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of DLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of DLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of DLL\n    void delete_front();\n    \n    // Delete Data from the Back of DLL\n    void delete_back();\n    \n    // Delete Data from the Middle of DLL\n    void del(int);\n    \n    // Length of the DLL\n    int length();\n    \n    // Print DLL\n    void printll();\n    \n};\n\n/* Delete Functions for Double Linked List */\n\nvoid DLL::delete_front () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the DLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    head = head-&gt;next;\n    head-&gt;prev = nullptr;\n}\n\nvoid DLL::delete_back () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the DLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t-&gt;next-&gt;next != nullptr) {\n        t = t-&gt;next;\n    }\n    t-&gt;next = nullptr;\n}\n\nvoid DLL::del(int pos) {\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    if (x == nullptr) {\n        cout &lt;&lt; \"There are no element in the DLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    y-&gt;next-&gt;prev = x;\n    x-&gt;next = y-&gt;next;\n}\n\n/* Insertion Functions for Double Linked List */\n\nvoid DLL::insert_front (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    t-&gt;next = head;\n    head-&gt;prev = t;\n    \n    head = t;\n    \n}\n\nvoid DLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    Node *x = head;\n    \n    while (x-&gt;next != nullptr) {\n        x = x-&gt;next;\n    }\n    x-&gt;next = t;\n    t-&gt;prev = x;\n}\n\nvoid DLL::insert (int d, int pos) {\n    \n    if (pos &gt; DLL::length()) {\n        DLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        DLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    t-&gt;next = y;\n    y-&gt;prev = t;\n    t-&gt;prev = x;\n    x-&gt;next = t;\n}\n\n/* Length of Double Linked List */\n\nint DLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        t = t-&gt;next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Double Linked List */\n\nvoid DLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"Linked List is Empty\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t != nullptr) {\n        if (t-&gt;next == nullptr) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\nint main () {\n    DLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout &lt;&lt; \"Elements of Linked List are:\" &lt;&lt; endl;\n    \n    l.printll();\n    \n    cout &lt;&lt; endl &lt;&lt; \"Count: \" &lt;&lt; l.length() &lt;&lt; endl;\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#circular-linked-list",
    "href": "notes/2023-10-25-C++/index.html#circular-linked-list",
    "title": "C++ Notes",
    "section": "Circular Linked List",
    "text": "Circular Linked List\n//  Circular_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass CLL : public Node {\n    Node* head;\n    Node* last;\n    \npublic:\n    CLL () {\n        head = nullptr;\n        last = nullptr;\n    }\n    \n    // Insert Data at the Front of CLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of CLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of CLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of CLL\n    void delete_front();\n    \n    // Delete Data from the Back of CLL\n    void delete_back();\n    \n    // Delete Data from the Middle of CLL\n    void del(int);\n    \n    // Length of the CLL\n    int length();\n    \n    // Print CLL\n    void printll();\n};\n\n\n/* Delete Functions for Circular Linked List */\n\nvoid CLL::delete_front() {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the CLL to delete!\" &lt;&lt; endl;\n    }\n    \n    head = head-&gt;next;\n    last-&gt;next = head;\n}\n\nvoid CLL::delete_back() {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the CLL to delete!\" &lt;&lt; endl;\n    }\n    \n    if (t-&gt;next == head) {\n        head = nullptr;\n        last = nullptr;\n    }\n    \n    while (t-&gt;next-&gt;next != head) {\n        t = t-&gt;next;\n    }\n    \n    last = t;\n    \n    last-&gt;next = head;\n}\n\nvoid CLL::del(int pos) {\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    if (x == nullptr) {\n        cout &lt;&lt; \"There are no element in the CLL to delete!\" &lt;&lt; endl;\n    }\n    \n    if (pos == CLL::length()) {\n        CLL::delete_back();\n    }\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    x-&gt;next = y-&gt;next;\n}\n\n/* Insertion Functions for Circular Linked List */\n\nvoid CLL::insert_front(int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        last = t;\n        last-&gt;next = head;\n        return;\n    }\n    \n    t-&gt;next = head;\n    head = t;\n    last-&gt;next = head;\n}\n\nvoid CLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        insert_front(d);\n        return;\n    }\n    \n    t-&gt;next = head;\n    last-&gt;next = t;\n    last = t;\n}\n\nvoid CLL::insert (int d, int pos) {\n    if (pos &gt; CLL::length()) {\n        CLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        CLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    t-&gt;next = y;\n    x-&gt;next = t;\n}\n\n/* Length of Double Linked List */\n\nint CLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    if (t == nullptr) {\n        return 0;\n    }\n    \n    c++;\n    t = t-&gt;next;\n    \n    while (t != head) {\n        t = t-&gt;next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Double Linked List */\n\nvoid CLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"Linked List is Empty\" &lt;&lt; endl;\n        return;\n    }\n    \n    cout &lt;&lt; t-&gt;data &lt;&lt; \"-&gt; \";\n    t = t-&gt;next;\n    \n    while (t != head) {\n        if (t-&gt;next == head) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\n\nint main () {\n    CLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout &lt;&lt; \"Elements of Linked List are:\" &lt;&lt; endl;\n    \n    l.printll();\n    \n    cout &lt;&lt; endl &lt;&lt; \"Count: \" &lt;&lt; l.length() &lt;&lt; endl;\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#stack",
    "href": "notes/2023-10-25-C++/index.html#stack",
    "title": "C++ Notes",
    "section": "Stack",
    "text": "Stack\n//  Stack.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass Stack : public Node {\n    Node* head;\n    int MAX;\n    \npublic:\n    \n    Stack (int m) {\n        head = nullptr;\n        MAX = m;\n    }\n    \n    // Push an element to the Stack\n    void push (int d);\n    \n    // Pop an element from the Stack\n    int pop ();\n    \n    // Check if Stack is Empty\n    bool isEmpty ();\n    \n    // Check if Stack is Full\n    bool isFull ();\n    \n    // Get the Top element from the Stack\n    int peek ();\n    \n    // Print the Stack\n    void print ();\n};\n\n/* Push an element to the Stack */\nvoid Stack::push (int d) {\n    if (Stack::isFull()) {\n        cout &lt;&lt; \"The Stack is Full. \" &lt;&lt; d &lt;&lt; \" element cannot be Inserted.\" &lt;&lt; endl;\n        return;\n    }\n    \n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        t-&gt;next = nullptr;\n        head = t;\n        return;\n    }\n    \n    t-&gt;next = head;\n    head = t;\n}\n\n/* Pop an element from the Stack */\nint Stack::pop () {\n    if (Stack::isEmpty()) {\n        cout &lt;&lt; \"The Stack is Empty. No Element is Present.\" &lt;&lt; endl;\n        return -1;\n    }\n    \n    Node *t = head;\n    \n    head = head-&gt;next;\n    \n    return t-&gt;data;\n}\n\n/* Check if the Stack is Empty */\nbool Stack::isEmpty () {\n    Node *t = head;\n    \n    if (head == nullptr) {\n        return true;\n    }\n    \n    return false;\n}\n\n/* Check if the Stack is Full */\nbool Stack::isFull () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        c++;\n        t = t-&gt;next;\n    }\n    \n    if (c == MAX) {\n        return true;\n    }\n    \n    return false;\n}\n\n/* Get the Top element from the Stack */\nint Stack::peek () {\n    Node *t = head;\n    \n    return t-&gt;data;\n}\n\n/* Print the Stack */\nvoid Stack::print () {\n    Node *t = head;\n    \n    while (t != nullptr) {\n        if (t-&gt;next == nullptr) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        }\n        else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\nint main () {\n    Stack s(5);\n    \n    s.push(1);\n    s.push(2);\n    s.push(3);\n    s.push(4);\n    s.push(5);\n    s.push(6);\n    \n    cout &lt;&lt; s.isEmpty() &lt;&lt; endl;\n    cout &lt;&lt; s.isFull() &lt;&lt; endl;\n    \n    cout &lt;&lt; \"Element Pop is : \" &lt;&lt; s.pop() &lt;&lt; endl;\n    \n    cout &lt;&lt; s.peek() &lt;&lt; endl;\n    \n    s.print();\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#reverse-a-single-linked-list-using-iteration",
    "href": "notes/2023-10-25-C++/index.html#reverse-a-single-linked-list-using-iteration",
    "title": "C++ Notes",
    "section": "Reverse a Single Linked List using Iteration",
    "text": "Reverse a Single Linked List using Iteration\n/* Reverse a SLL using Iteration */\nvoid SLL::rev_iter () {\n    Node *cur = head, *prev = nullptr;\n    \n    while (cur != nullptr) {\n        Node *t = cur-&gt;next;\n        cur-&gt;next = prev;\n        prev = cur;\n        cur = t;\n    }\n    head = prev;\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bhanu Prasanna",
    "section": "",
    "text": "M.Sc. Data Science at TU Dortmund\n\n\n\nIt‚Äôs Black. üëÅÔ∏èüëÅÔ∏è are Safe"
  },
  {
    "objectID": "projects/2023-10-25-kbp-nse/index.html",
    "href": "projects/2023-10-25-kbp-nse/index.html",
    "title": "kbp-nse",
    "section": "",
    "text": "CitationBibTeX citation:@online{prasanna koppolu2023,\n  author = {Prasanna Koppolu, Bhanu},\n  title = {Kbp-Nse},\n  date = {2023-10-25},\n  url = {https://bhanuprasanna527.github.io/projects/2023-10-25-kbp-nse/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nPrasanna Koppolu, Bhanu. 2023. ‚ÄúKbp-Nse.‚Äù October 25, 2023.\nhttps://bhanuprasanna527.github.io/projects/2023-10-25-kbp-nse/."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html",
    "href": "posts/2023-10-25-Setup-Mac/index.html",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "",
    "text": "Let‚Äôs prepare your Apple Silicon Mac, whether it‚Äôs an M1 or M2 variant, for machine learning and data science."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#who-will-benefit-from-this-blog-post",
    "href": "posts/2023-10-25-Setup-Mac/index.html#who-will-benefit-from-this-blog-post",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Who will benefit from this blog post?",
    "text": "Who will benefit from this blog post?\nIf you have recently acquired an Apple Silicon Mac, specifically one of the M1 or M2 models, and you‚Äôre eager to embark on machine learning and data science endeavors, this post is tailored for you."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#what-to-expect-from-this-post",
    "href": "posts/2023-10-25-Setup-Mac/index.html#what-to-expect-from-this-post",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "What to expect from this post:",
    "text": "What to expect from this post:\nThis post is designed to guide you through the process of installing essential machine learning and data science packages, including TensorFlow, PyTorch, Hugging Face Transformer, pandas, NumPy, Jupyter, matplotlib, and scikit-learn, on your Apple Silicon Mac. It also ensures that these packages run smoothly by providing sample code."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#are-you-a-novice-or-an-expert",
    "href": "posts/2023-10-25-Setup-Mac/index.html#are-you-a-novice-or-an-expert",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Are you a novice or an expert?",
    "text": "Are you a novice or an expert?\nIf you‚Äôre new to the setup of environments and software packages, consider watching the video version in conjunction with the comprehensive written instructions below.\nFor those experienced in setting up environments, the concise text-based instructions should suffice."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#video-guide-available",
    "href": "posts/2023-10-25-Setup-Mac/index.html#video-guide-available",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Video guide available:",
    "text": "Video guide available:\nYou can access a detailed step-by-step video guide of the content covered in this article on YouTube."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#lets-start",
    "href": "posts/2023-10-25-Setup-Mac/index.html#lets-start",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Let‚Äôs Start üèÅ",
    "text": "Let‚Äôs Start üèÅ\nI will detail each step so a beginner can also be transition their journey to data science smoothly.\n\n1 - Install Homebrew\nVisit - Homebrew\nCopy and Paste the command present on the website or use the below command in the Terminal:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n\n2 - Install Anaconda or MiniConda\nI prefer Anaconda and I will be using it for further process.\nVisit - Anaconda Downloads\nVisit - Installation Guide\nFor Command Line -\nbash ~/Downloads/Anaconda\\ 2023.09\\ MacOSX-arm64.sh\nSet Conda Base to Activate by default -\nconda config --set auto_activate_base True"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nC++ Notes\n\n\n\n\n\n\n\nNotes\n\n\nC++\n\n\nChallenge\n\n\n\n\nDistilled C++ Notes\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "challenges.html",
    "href": "challenges.html",
    "title": "Challenges",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nkbp-nse\n\n\n\n\n\n\n\nProjects\n\n\nPython\n\n\nFinance\n\n\n\n\nMy personal Stock Data Retriever Project kbp-nse.\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Code\nimport numpy as np\nimport pandas as pd"
  },
  {
    "objectID": "about.html#this-is-a-python-test",
    "href": "about.html#this-is-a-python-test",
    "title": "About",
    "section": "",
    "text": "Code\nimport numpy as np\nimport pandas as pd"
  }
]