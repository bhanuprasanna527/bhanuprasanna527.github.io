[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nSetup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes\n\n\n\n\n\n\n\nFirst\n\n\nBlog\n\n\nTest\n\n\n\n\nInstalling TensorFlow, PyTorch, and other Libraries on Mac\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html",
    "href": "notes/2023-10-25-C++/index.html",
    "title": "C++ Notes",
    "section": "",
    "text": "Definition - Time Complexity is the relationship about how the time will grow as the input grows.\nTime Complexity != Total Time Taken by a Machine to execute.\nThere are mainly 4 points for Time Complexity:\n\nAlways look for the Worst Case Time Complexity.\nAlways look at the Complexity for Large Data.\nAlways Ignore Constants.\nAlways Ignore Less Dominant Terms. From Point 2\n\n\n\n\n\n\nIf the recurrence become more complex then finding the time complexity will become harder. So, Akra-Bazzi method is the easy and simple method to find the Time Complexity.\nThe method goes as follows:\nLet \\(p\\) be the unique real number for which \\[\\sum_{i=1}^{k} a_ib_i^p = 1\\]\nThen,\n\\[T(x) = \\Theta\\biggl(x^p + x^p \\int_1^x \\frac{g(u)}{u^{p+1}} du\\biggl)\\]\n\n\n\nThe usage of Asymptotic Notation is for specifying and for the identification of the upper and lower bounds.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)}\\]\nBelow are the Asymptotic Notations:\n\n\nThis is the Upper Bound and the complexity cannot go beyond this Upper Bound.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThis is the opposite of Big - \\(O\\) Notation. This is the Lower Bound and the function complexity will atleast require Lower Bound complexity.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &gt; 0\\]\n\n\n\nThe Big - \\(\\Theta\\) Notation was created when a function lies in both Upper Bound (Big - \\(O\\)) and Lower Bound (Big - \\(\\Omega\\)).\n\\[0 &lt; \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThe Little - \\(o\\) is same as Big - \\(O\\) but it is slightly loose and strictly lesser than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0\\]\n\n\n\nThe Little - \\(\\omega\\) is same as Big - \\(\\Omega\\) but it is slightly loose and strictly greater than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\]\n\n\n\n\n\nSpace Complexity is measured by combining the Input Space and the Auxilary Space. The same Asymptotic Notations discussed above are the ones used for Space Complexity.\n\n\n\n\n\nResources Used:\n\nClick Here!\n\n\nThis is the end of Day - 1."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#time-complexity",
    "href": "notes/2023-10-25-C++/index.html#time-complexity",
    "title": "C++ Notes",
    "section": "",
    "text": "Definition - Time Complexity is the relationship about how the time will grow as the input grows.\nTime Complexity != Total Time Taken by a Machine to execute.\nThere are mainly 4 points for Time Complexity:\n\nAlways look for the Worst Case Time Complexity.\nAlways look at the Complexity for Large Data.\nAlways Ignore Constants.\nAlways Ignore Less Dominant Terms. From Point 2"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#akra-bazzi-time-complexity-method",
    "href": "notes/2023-10-25-C++/index.html#akra-bazzi-time-complexity-method",
    "title": "C++ Notes",
    "section": "",
    "text": "If the recurrence become more complex then finding the time complexity will become harder. So, Akra-Bazzi method is the easy and simple method to find the Time Complexity.\nThe method goes as follows:\nLet \\(p\\) be the unique real number for which \\[\\sum_{i=1}^{k} a_ib_i^p = 1\\]\nThen,\n\\[T(x) = \\Theta\\biggl(x^p + x^p \\int_1^x \\frac{g(u)}{u^{p+1}} du\\biggl)\\]"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#asymptotic-notation",
    "href": "notes/2023-10-25-C++/index.html#asymptotic-notation",
    "title": "C++ Notes",
    "section": "",
    "text": "The usage of Asymptotic Notation is for specifying and for the identification of the upper and lower bounds.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)}\\]\nBelow are the Asymptotic Notations:\n\n\nThis is the Upper Bound and the complexity cannot go beyond this Upper Bound.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThis is the opposite of Big - \\(O\\) Notation. This is the Lower Bound and the function complexity will atleast require Lower Bound complexity.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &gt; 0\\]\n\n\n\nThe Big - \\(\\Theta\\) Notation was created when a function lies in both Upper Bound (Big - \\(O\\)) and Lower Bound (Big - \\(\\Omega\\)).\n\\[0 &lt; \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty\\]\n\n\n\nThe Little - \\(o\\) is same as Big - \\(O\\) but it is slightly loose and strictly lesser than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0\\]\n\n\n\nThe Little - \\(\\omega\\) is same as Big - \\(\\Omega\\) but it is slightly loose and strictly greater than.\n\\[\\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\]"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#space-complexity",
    "href": "notes/2023-10-25-C++/index.html#space-complexity",
    "title": "C++ Notes",
    "section": "",
    "text": "Space Complexity is measured by combining the Input Space and the Auxilary Space. The same Asymptotic Notations discussed above are the ones used for Space Complexity."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#linear-recurrence-homogenous-and-non-homogenous",
    "href": "notes/2023-10-25-C++/index.html#linear-recurrence-homogenous-and-non-homogenous",
    "title": "C++ Notes",
    "section": "",
    "text": "Resources Used:\n\nClick Here!\n\n\nThis is the end of Day - 1."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#recursion",
    "href": "notes/2023-10-25-C++/index.html#recursion",
    "title": "C++ Notes",
    "section": "Recursion",
    "text": "Recursion\n\nImportant Points\n\nRecursion helps in solving bigger/complex problems into smaller problems which can be solved in a simple way.\nYou can convert a Recursion solution into Iterative and Vice Versa.\nSpace Complexity is not constant due to Recursive Calls.\n\n\n\nTypes of Recurrence Relations\n\nLinear Recurrence Relation\nDivide & Conquer Recurrence Relation\n\n\n\nHow to understand & approach a problem?\n\nIdentify if you can break down problem into smaller problems.\nWrite the Recurrence Relations if needed.\nDraw the Recursive Tree.\nAbout the Tree:\n\nSee the flow of functions, how they are getting into the stack.\nIdentify and Focus on Left Tree Calls and Right Tree Calls.\nDraw the tree and pointers using Pen & Paper for better understanding. *\nUse a debugger to see the flow.\n\nSee how the values and what type of values are returned at each step. See where the function will come out. In the end you will come out of the main function.\nThree Variables to concentrate on:\n\nArguments\nReturn Type\nBody of Function\n\nResources used:\n\nClick Here!"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#math-for-dsa",
    "href": "notes/2023-10-25-C++/index.html#math-for-dsa",
    "title": "C++ Notes",
    "section": "Math for DSA",
    "text": "Math for DSA\n\nResources used:\n\nMath for DSA 1 - Click Here!\nMath for DSA 2 - Click Here!\n\n\nThis is the end of Day - 2."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#c-start",
    "href": "notes/2023-10-25-C++/index.html#c-start",
    "title": "C++ Notes",
    "section": "C++ Start",
    "text": "C++ Start\n\nI have solved 18 Hackerrank Problems in the C++ section. - Click Here!."
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#c-from-book",
    "href": "notes/2023-10-25-C++/index.html#c-from-book",
    "title": "C++ Notes",
    "section": "C++ from Book",
    "text": "C++ from Book\n\nC++ developed by Bjarne Stroustroup at Bell Labs (1979).\n\n\nLearning Language Tradition - Hello, World! Program\n// Preprocessor Directive\n#include &lt;iostream&gt;\n\n// Start of the Program\nint main() {\n  // Tell the compiler what namespace to search in\n  using namespace std;\n\n  // Write to the screen using std::cout\n  cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n  // Return a value to the OS\n  return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#leetcode-questions-answers",
    "href": "notes/2023-10-25-C++/index.html#leetcode-questions-answers",
    "title": "C++ Notes",
    "section": "LeetCode Questions & Answers",
    "text": "LeetCode Questions & Answers\n\nTwo Sum\n//  Two_Sum.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {\n        int l = nums.size();\n        \n        for (int i = 0; i &lt; l; i++) {\n            for (int j = 0; j &lt; l && i != j; j ++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n\n        return {};\n    }\n};\n\n\nRemove Duplicates from Sorted Array\n//  Remove_Duplicates_from_Sorted_Array.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;& v) {\n        int j = 1;\n\n        for (auto i = v.begin() + 1; i != v.end(); i++) {\n            if (*i != *(i - 1)) {\n                v[j] = *i;\n                j++;\n            }\n        }\n\n        return j;\n    }\n};\n\n\nRemove Element\n//  Remove_Element.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int removeElement(vector&lt;int&gt;& v, int val) {\n        int j = 0;\n\n        for (auto i = v.begin(); i != v.end(); i++) {\n            if (*i != val) {\n                v[j] = *i;\n                j++;\n            }\n        }\n\n        return j;\n    }\n};\n\n\nSearch Insert Position\n//  Search_Insert_Position.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int searchInsert(vector&lt;int&gt;& nums, int target) {\n        auto x = std::lower_bound(nums.begin(), nums.end(), target);\n\n        cout &lt;&lt; (x - nums.begin()) &lt;&lt; endl;\n\n        return x - nums.begin();\n    }\n};\n\n\nPlus One\n//  Plus_One.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n//  Not the Best Solution - Must Learn How to Optimize a Solution.\n\n\nclass Solution {\npublic:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;& v) {\n        int c = 0, l = v.size();\n\n        for (int i = l-1; i &gt;= 0; i--) {\n            if (i == l-1) {\n                if (v[i] == 9) {\n                    v[i] = 0;\n                    c = 1;\n                } else {\n                    v[i] += 1;\n                    return v;\n                }\n            } else {\n                if (v[i] == 9) {\n                    v[i] = 0;\n                    c = 1;\n                } else {\n                    v[i] += c;\n                    return v;\n                }\n            }\n        }\n\n        if (*v.begin() == 0) {\n            v.insert(v.begin(), 1);\n        }\n\n        return v;\n    }\n};"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#leetcode-questions-answers-1",
    "href": "notes/2023-10-25-C++/index.html#leetcode-questions-answers-1",
    "title": "C++ Notes",
    "section": "LeetCode Questions & Answers",
    "text": "LeetCode Questions & Answers\n\nMerge Sorted Array\n//  Merge_Sorted_Array.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    void merge(vector&lt;int&gt;& nums1, int m, vector&lt;int&gt;& nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n\n        while (j &gt;= 0) {\n            if (i &gt;= 0 && nums1[i] &gt; nums2[j]) {\n                nums1[k] = nums1[i];\n                i--;\n            } else {\n                nums1[k] = nums2[j];\n                j--;\n            }\n            k--;\n        }\n    }\n};\n\n\nPascal’s Triangle\n//  Pascal's_Triangle.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {\n        vector&lt;vector&lt;int&gt;&gt; v;\n\n        for (int i = 0; i &lt; numRows; i++) {\n            vector&lt;int&gt; x(i+1, 1);\n            for (int j = 1; j &lt; i; j++) {\n                x[j] = v[i-1][j] + v[i-1][j-1];\n            }\n            v.push_back(x);\n        }\n        return v;\n    }\n};\n\n\nPascal’s Triangle 2\n//  Pascal's_Triange_2.cpp\n//  LeetCode - C++\n//  Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    vector&lt;int&gt; getRow(int rowIndex) {\n        vector&lt;vector&lt;int&gt;&gt; v;\n        vector&lt;int&gt; xv;\n\n        for (int i = 0; i &lt;= rowIndex; i++) {\n            vector&lt;int&gt; x(i+1, 1);\n\n            for (int j = 1; j &lt; i; j++) {\n                x[j] = v[i-1][j] + v[i-1][j-1];\n            }\n            if (i == rowIndex) {\n                return x;\n            }\n\n            v.push_back(x);\n        }\n\n        return xv;\n    }\n};\n\n\nBest Time to Buy and Sell Stock\n// Best_Time_to_Buy_and_Sell_Stock.cpp\n// LeetCode - C++\n// Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;& prices) {\n        int lsf = INT_MAX;\n        int op = 0;\n        int pist = 0;\n\n        for (int i = 0; i &lt; prices.size(); i++) {\n            if (prices[i] &lt; lsf) {\n                lsf = prices[i];\n            }\n            pist = prices[i] - lsf;\n            if (pist &gt; op) {\n                op = pist;\n            }\n        }\n        return op;\n    }\n};\n\n\nSingle Number\n// Single_Number.cpp\n// LeetCode - C++\n// Created by Bhanu Prasanna\n\nclass Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;& nums) {\n        int ans = 0;\n\n        for (auto x:nums) {\n            ans ^= x;\n        }\n\n        return ans;\n    }\n};"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#single-linked-list",
    "href": "notes/2023-10-25-C++/index.html#single-linked-list",
    "title": "C++ Notes",
    "section": "Single Linked List",
    "text": "Single Linked List\n//  Single_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass SLL : public Node {\n    Node* head;\n    \npublic:\n    SLL () {\n        head = nullptr;\n    }\n    \n    // Insert Data at the Front of SLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of SLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of SLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of SLL\n    void delete_front();\n    \n    // Delete Data from the Back of SLL\n    void delete_back();\n    \n    // Delete Data from the Middle of SLL\n    void del(int);\n    \n    // Length of the SLL\n    int length();\n    \n    // Print SLL\n    void printll();\n    \n};\n\n/* Delete Functions for Single Linked List */\n\nvoid SLL::delete_front () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the SLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    head = head-&gt;next;\n}\n\nvoid SLL::delete_back () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the SLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t-&gt;next-&gt;next != nullptr) {\n        t = t-&gt;next;\n    }\n    t-&gt;next = nullptr;\n}\n\nvoid SLL::del(int pos) {\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    if (x == nullptr) {\n        cout &lt;&lt; \"There are no element in the SLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    x-&gt;next = y-&gt;next;\n}\n\n/* Insertion Functions for Single Linked List */\n\nvoid SLL::insert_front (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    t-&gt;next = head;\n    \n    head = t;\n    \n}\n\nvoid SLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    Node *x = head;\n    \n    while (x-&gt;next != nullptr) {\n        x = x-&gt;next;\n    }\n    x-&gt;next = t;\n}\n\nvoid SLL::insert (int d, int pos) {\n    \n    if (pos &gt; SLL::length()) {\n        SLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        SLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    t-&gt;next = y;\n    x-&gt;next = t;\n}\n\n/* Length of Single Linked List */\n\nint SLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        t = t-&gt;next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Single Linked List */\n\nvoid SLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"Linked List is Empty\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t != nullptr) {\n        if (t-&gt;next == nullptr) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\nint main () {\n    SLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout &lt;&lt; \"Elements of Linked List are:\" &lt;&lt; endl;\n    \n    l.printll();\n    \n    cout &lt;&lt; endl &lt;&lt; \"Count: \" &lt;&lt; l.length() &lt;&lt; endl;\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#double-linked-list",
    "href": "notes/2023-10-25-C++/index.html#double-linked-list",
    "title": "C++ Notes",
    "section": "Double Linked List",
    "text": "Double Linked List\n//  Double_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n        prev = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DLL : public Node {\n    Node* head;\n    \npublic:\n    DLL () {\n        head = nullptr;\n    }\n    \n    // Insert Data at the Front of DLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of DLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of DLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of DLL\n    void delete_front();\n    \n    // Delete Data from the Back of DLL\n    void delete_back();\n    \n    // Delete Data from the Middle of DLL\n    void del(int);\n    \n    // Length of the DLL\n    int length();\n    \n    // Print DLL\n    void printll();\n    \n};\n\n/* Delete Functions for Double Linked List */\n\nvoid DLL::delete_front () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the DLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    head = head-&gt;next;\n    head-&gt;prev = nullptr;\n}\n\nvoid DLL::delete_back () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the DLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t-&gt;next-&gt;next != nullptr) {\n        t = t-&gt;next;\n    }\n    t-&gt;next = nullptr;\n}\n\nvoid DLL::del(int pos) {\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    if (x == nullptr) {\n        cout &lt;&lt; \"There are no element in the DLL to delete!\" &lt;&lt; endl;\n        return;\n    }\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    y-&gt;next-&gt;prev = x;\n    x-&gt;next = y-&gt;next;\n}\n\n/* Insertion Functions for Double Linked List */\n\nvoid DLL::insert_front (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    t-&gt;next = head;\n    head-&gt;prev = t;\n    \n    head = t;\n    \n}\n\nvoid DLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        return;\n    }\n    \n    Node *x = head;\n    \n    while (x-&gt;next != nullptr) {\n        x = x-&gt;next;\n    }\n    x-&gt;next = t;\n    t-&gt;prev = x;\n}\n\nvoid DLL::insert (int d, int pos) {\n    \n    if (pos &gt; DLL::length()) {\n        DLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        DLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    t-&gt;next = y;\n    y-&gt;prev = t;\n    t-&gt;prev = x;\n    x-&gt;next = t;\n}\n\n/* Length of Double Linked List */\n\nint DLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        t = t-&gt;next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Double Linked List */\n\nvoid DLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"Linked List is Empty\" &lt;&lt; endl;\n        return;\n    }\n    \n    while (t != nullptr) {\n        if (t-&gt;next == nullptr) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\nint main () {\n    DLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout &lt;&lt; \"Elements of Linked List are:\" &lt;&lt; endl;\n    \n    l.printll();\n    \n    cout &lt;&lt; endl &lt;&lt; \"Count: \" &lt;&lt; l.length() &lt;&lt; endl;\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#circular-linked-list",
    "href": "notes/2023-10-25-C++/index.html#circular-linked-list",
    "title": "C++ Notes",
    "section": "Circular Linked List",
    "text": "Circular Linked List\n//  Circular_Linked_List.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass CLL : public Node {\n    Node* head;\n    Node* last;\n    \npublic:\n    CLL () {\n        head = nullptr;\n        last = nullptr;\n    }\n    \n    // Insert Data at the Front of CLL\n    void insert_front(int);\n    \n    // Insert Data at the Back of CLL\n    void insert_back(int);\n    \n    // Insert Data in the Middle of CLL\n    void insert(int, int);\n    \n    // Delete Data from the Front of CLL\n    void delete_front();\n    \n    // Delete Data from the Back of CLL\n    void delete_back();\n    \n    // Delete Data from the Middle of CLL\n    void del(int);\n    \n    // Length of the CLL\n    int length();\n    \n    // Print CLL\n    void printll();\n};\n\n\n/* Delete Functions for Circular Linked List */\n\nvoid CLL::delete_front() {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the CLL to delete!\" &lt;&lt; endl;\n    }\n    \n    head = head-&gt;next;\n    last-&gt;next = head;\n}\n\nvoid CLL::delete_back() {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"There are no element in the CLL to delete!\" &lt;&lt; endl;\n    }\n    \n    if (t-&gt;next == head) {\n        head = nullptr;\n        last = nullptr;\n    }\n    \n    while (t-&gt;next-&gt;next != head) {\n        t = t-&gt;next;\n    }\n    \n    last = t;\n    \n    last-&gt;next = head;\n}\n\nvoid CLL::del(int pos) {\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    if (x == nullptr) {\n        cout &lt;&lt; \"There are no element in the CLL to delete!\" &lt;&lt; endl;\n    }\n    \n    if (pos == CLL::length()) {\n        CLL::delete_back();\n    }\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    x-&gt;next = y-&gt;next;\n}\n\n/* Insertion Functions for Circular Linked List */\n\nvoid CLL::insert_front(int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        head = t;\n        last = t;\n        last-&gt;next = head;\n        return;\n    }\n    \n    t-&gt;next = head;\n    head = t;\n    last-&gt;next = head;\n}\n\nvoid CLL::insert_back (int d) {\n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        insert_front(d);\n        return;\n    }\n    \n    t-&gt;next = head;\n    last-&gt;next = t;\n    last = t;\n}\n\nvoid CLL::insert (int d, int pos) {\n    if (pos &gt; CLL::length()) {\n        CLL::insert_back(d);\n        return;\n    }\n    \n    if (pos == 1) {\n        CLL::insert_front(d);\n        return;\n    }\n    \n    Node *t = new Node(d);\n    Node *x = head;\n    Node *y = head-&gt;next;\n    \n    for (int i = 0; i &lt; pos - 2; i++) {\n        x = x-&gt;next;\n        y = y-&gt;next;\n    }\n    \n    t-&gt;next = y;\n    x-&gt;next = t;\n}\n\n/* Length of Double Linked List */\n\nint CLL::length () {\n    Node *t = head;\n    int c = 0;\n    \n    if (t == nullptr) {\n        return 0;\n    }\n    \n    c++;\n    t = t-&gt;next;\n    \n    while (t != head) {\n        t = t-&gt;next;\n        c++;\n    }\n    \n    return c;\n}\n\n/* Print Double Linked List */\n\nvoid CLL::printll () {\n    Node *t = head;\n    \n    if (t == nullptr) {\n        cout &lt;&lt; \"Linked List is Empty\" &lt;&lt; endl;\n        return;\n    }\n    \n    cout &lt;&lt; t-&gt;data &lt;&lt; \"-&gt; \";\n    t = t-&gt;next;\n    \n    while (t != head) {\n        if (t-&gt;next == head) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\n\nint main () {\n    CLL l;\n    \n    l.insert_front(10);\n    l.insert_back(20);\n    l.insert_back(40);\n    l.insert_back(50);\n    l.insert_back(60);\n    \n    l.insert(30, 3);\n    \n    l.insert(30,3);\n    \n    l.del(3);\n    \n    l.delete_back();\n    l.delete_front();\n    \n    cout &lt;&lt; \"Elements of Linked List are:\" &lt;&lt; endl;\n    \n    l.printll();\n    \n    cout &lt;&lt; endl &lt;&lt; \"Count: \" &lt;&lt; l.length() &lt;&lt; endl;\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#stack",
    "href": "notes/2023-10-25-C++/index.html#stack",
    "title": "C++ Notes",
    "section": "Stack",
    "text": "Stack\n//  Stack.cpp\n//  DS - C++\n//  Created by Bhanu Prasanna\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node () {\n        data = 0;\n        next = nullptr;\n    }\n    \n    Node (int d) {\n        data = d;\n        next = nullptr;\n    }\n};\n\nclass Stack : public Node {\n    Node* head;\n    int MAX;\n    \npublic:\n    \n    Stack (int m) {\n        head = nullptr;\n        MAX = m;\n    }\n    \n    // Push an element to the Stack\n    void push (int d);\n    \n    // Pop an element from the Stack\n    int pop ();\n    \n    // Check if Stack is Empty\n    bool isEmpty ();\n    \n    // Check if Stack is Full\n    bool isFull ();\n    \n    // Get the Top element from the Stack\n    int peek ();\n    \n    // Print the Stack\n    void print ();\n};\n\n/* Push an element to the Stack */\nvoid Stack::push (int d) {\n    if (Stack::isFull()) {\n        cout &lt;&lt; \"The Stack is Full. \" &lt;&lt; d &lt;&lt; \" element cannot be Inserted.\" &lt;&lt; endl;\n        return;\n    }\n    \n    Node *t = new Node(d);\n    \n    if (head == nullptr) {\n        t-&gt;next = nullptr;\n        head = t;\n        return;\n    }\n    \n    t-&gt;next = head;\n    head = t;\n}\n\n/* Pop an element from the Stack */\nint Stack::pop () {\n    if (Stack::isEmpty()) {\n        cout &lt;&lt; \"The Stack is Empty. No Element is Present.\" &lt;&lt; endl;\n        return -1;\n    }\n    \n    Node *t = head;\n    \n    head = head-&gt;next;\n    \n    return t-&gt;data;\n}\n\n/* Check if the Stack is Empty */\nbool Stack::isEmpty () {\n    Node *t = head;\n    \n    if (head == nullptr) {\n        return true;\n    }\n    \n    return false;\n}\n\n/* Check if the Stack is Full */\nbool Stack::isFull () {\n    Node *t = head;\n    int c = 0;\n    \n    while (t != nullptr) {\n        c++;\n        t = t-&gt;next;\n    }\n    \n    if (c == MAX) {\n        return true;\n    }\n    \n    return false;\n}\n\n/* Get the Top element from the Stack */\nint Stack::peek () {\n    Node *t = head;\n    \n    return t-&gt;data;\n}\n\n/* Print the Stack */\nvoid Stack::print () {\n    Node *t = head;\n    \n    while (t != nullptr) {\n        if (t-&gt;next == nullptr) {\n            cout &lt;&lt; t-&gt;data &lt;&lt; endl;\n        }\n        else {\n            cout &lt;&lt; t-&gt;data &lt;&lt; \" -&gt; \";\n        }\n        t = t-&gt;next;\n    }\n}\n\nint main () {\n    Stack s(5);\n    \n    s.push(1);\n    s.push(2);\n    s.push(3);\n    s.push(4);\n    s.push(5);\n    s.push(6);\n    \n    cout &lt;&lt; s.isEmpty() &lt;&lt; endl;\n    cout &lt;&lt; s.isFull() &lt;&lt; endl;\n    \n    cout &lt;&lt; \"Element Pop is : \" &lt;&lt; s.pop() &lt;&lt; endl;\n    \n    cout &lt;&lt; s.peek() &lt;&lt; endl;\n    \n    s.print();\n    \n    return 0;\n}"
  },
  {
    "objectID": "notes/2023-10-25-C++/index.html#reverse-a-single-linked-list-using-iteration",
    "href": "notes/2023-10-25-C++/index.html#reverse-a-single-linked-list-using-iteration",
    "title": "C++ Notes",
    "section": "Reverse a Single Linked List using Iteration",
    "text": "Reverse a Single Linked List using Iteration\n/* Reverse a SLL using Iteration */\nvoid SLL::rev_iter () {\n    Node *cur = head, *prev = nullptr;\n    \n    while (cur != nullptr) {\n        Node *t = cur-&gt;next;\n        cur-&gt;next = prev;\n        prev = cur;\n        cur = t;\n    }\n    head = prev;\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bhanu Prasanna",
    "section": "",
    "text": "M.Sc. Data Science at TU Dortmund\n\n\n\nIt’s Black. 👁️👁️ are Safe"
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html",
    "title": "90 Days DSA Challenge",
    "section": "",
    "text": "My Name is Bhanu Prasanna, Started M.Sc. Data Science at TU Dortmund. \n\nThat is all there is to know about me. Let’s Start with the challenge."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#hi-there-lets-start",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#hi-there-lets-start",
    "title": "90 Days DSA Challenge",
    "section": "",
    "text": "My Name is Bhanu Prasanna, Started M.Sc. Data Science at TU Dortmund. \n\nThat is all there is to know about me. Let’s Start with the challenge."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#days-dsa-challenge",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#days-dsa-challenge",
    "title": "90 Days DSA Challenge",
    "section": "90 Days DSA Challenge",
    "text": "90 Days DSA Challenge\nWhy am I doing this? I have created a python library, learnt how to use Tensorflow and other ML Libraries. There was always a missing piece needed to be filled.\nThe missing piece is DSA."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#shall-we-start-now-already",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#shall-we-start-now-already",
    "title": "90 Days DSA Challenge",
    "section": "Shall we Start Now Already? 🤨",
    "text": "Shall we Start Now Already? 🤨\nFrom 26th October, 2023 the challenge will officially start.\n\nNotes Available. Click Here!\n\nLet’s go Step-by-Step.\n\nChoosing the Programming Language \n\n\nI. Choosing the Programming Language\nAs I want to become a Quant Developer. The most used programming language is C++.\n\nNote: Most firms in the world use the latest C++ version. The current version of C++ is 20 as of the time of this challenge.\n\nThe resources that I used for Learning C++ are provided below:\n\nYouTube - Time and Space Complexity - ✅ 26-10-2023\nYouTube - Introduction to Recursion - ✅ 27-10-2023\nYouTube - Maths for DSA - 1 - ✅ 27-10-2023\nYouTube - Math for DSA - 2 - ✅ 27-10-2023"
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-1---time-and-space-complexity",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-1---time-and-space-complexity",
    "title": "90 Days DSA Challenge",
    "section": "Day 1 - Time and Space Complexity",
    "text": "Day 1 - Time and Space Complexity\nFor Day 1 - I don’t want to start coding but instead understand the more theoretical parts.\nI have completed Time and Space Complexity from the YouTube Video. Click Here!."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-2---recursion-and-math-for-dsa",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-2---recursion-and-math-for-dsa",
    "title": "90 Days DSA Challenge",
    "section": "Day 2 - Recursion and Math for DSA",
    "text": "Day 2 - Recursion and Math for DSA\nFor Day 2 - I will be going through Recursion concept and Math for DSA.\nI have completed Recursion from the YouTube Video. Click Here!.\nI have completed Math for DSA - 1 from the YouTube Video. Click Here!.\nI have completed Math for DSA - 2 from the YouTube Video. Click Here!."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-3---c-start",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-3---c-start",
    "title": "90 Days DSA Challenge",
    "section": "Day 3 - C++ Start ❄️",
    "text": "Day 3 - C++ Start ❄️\nFor Day 3 - I am going to start C++ learning from start. I have a foundation but need to improve this a lot.\nI have completed 5 hours C++ from this YouTube Video. Click Here!.\nI have solved 18 problems in C++ Hackerrank. - Click Here!."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-4---c-book",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-4---c-book",
    "title": "90 Days DSA Challenge",
    "section": "Day 4 - C++ Book",
    "text": "Day 4 - C++ Book\nFor Day 4 - I am going to solve more problems in Hackerrank and read the Sams C++ book.\nI have solved total of 28 Hackerrank Problems in the C++ section. I feel confident in C++. - Click Here!.\nRead 2 Lessons form Sams C++ Book."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-5---c-problems",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-5---c-problems",
    "title": "90 Days DSA Challenge",
    "section": "Day 5 - C++ Problems",
    "text": "Day 5 - C++ Problems\nFor Day 5 - I am going to start solving LeetCode while simultaneously start learning DSA.\nI have solved 5 LeetCode problems in the Array Section. - Click Here!."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-6---c-problems",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-6---c-problems",
    "title": "90 Days DSA Challenge",
    "section": "Day 6 - C++ Problems",
    "text": "Day 6 - C++ Problems\nFor Day 6 - I am going to solve more problems in LeetCode and read a Lesson from Sams C++ Book.\nI have completed solving 5 LeetCode Problems in the Array Section. - Click Here!.\nI have completed reading Lesson 4 from Sams C++ Book."
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-7---data-structures-in-c",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-7---data-structures-in-c",
    "title": "90 Days DSA Challenge",
    "section": "Day 7 - Data Structures in C++",
    "text": "Day 7 - Data Structures in C++\nFor Day 7 - I am going to start Data Structures. In DS, I will be starting with Linked List types and it’s operations.\nI have completed Single Linked List, Double Linked List, and Circular Linked List.\nImplemented Operations for Variants of Linked List’s are:\n\nInsert Front\nInsert Back\nInsert Middle\nDelete Front\nDelete Back\nDelete Middle\nLength\nPrint Linked List\n\nI have completed Stack.\nImplemented Operations for Stack are:\n\nPush\nPop\nPeek\nStack is Empty\nStack is Full\nPrint Stack"
  },
  {
    "objectID": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-8---data-structures-in-c",
    "href": "challenges/2023-10-25-90_DSA_Challenge/index.html#day-8---data-structures-in-c",
    "title": "90 Days DSA Challenge",
    "section": "Day 8 - Data Structures in C++",
    "text": "Day 8 - Data Structures in C++\nFor Day 8 - I am going to do Queue Data Structures and start using NeetCode website to prepare DSA.\nI have completed Simple Queue using Linked List and Reverse a SLL using Iteration."
  },
  {
    "objectID": "challenges.html",
    "href": "challenges.html",
    "title": "Challenges",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\n90 Days DSA Challenge\n\n\n\n\n\n\n\nChallenge\n\n\nDSA\n\n\nCode\n\n\n\n\nLet’s Start\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nNeetCode 150\n\n\n\n\n\n\n\nNotes\n\n\nC++\n\n\nChallenge\n\n\n\n\nLearning by Solving NeetCode 150\n\n\n\n\n\n\nNov 4, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\n  \n\n\n\n\nC++ Notes\n\n\n\n\n\n\n\nNotes\n\n\nC++\n\n\nChallenge\n\n\n\n\nDistilled C++ Notes\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html",
    "href": "posts/2023-10-25-Setup-Mac/index.html",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "",
    "text": "Let’s prepare your Apple Silicon Mac, whether it’s an M1 or M2 variant, for machine learning and data science."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#who-will-benefit-from-this-blog-post",
    "href": "posts/2023-10-25-Setup-Mac/index.html#who-will-benefit-from-this-blog-post",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Who will benefit from this blog post?",
    "text": "Who will benefit from this blog post?\nIf you have recently acquired an Apple Silicon Mac, specifically one of the M1 or M2 models, and you’re eager to embark on machine learning and data science endeavors, this post is tailored for you."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#what-to-expect-from-this-post",
    "href": "posts/2023-10-25-Setup-Mac/index.html#what-to-expect-from-this-post",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "What to expect from this post:",
    "text": "What to expect from this post:\nThis post is designed to guide you through the process of installing essential machine learning and data science packages, including TensorFlow, PyTorch, Hugging Face Transformer, pandas, NumPy, Jupyter, matplotlib, and scikit-learn, on your Apple Silicon Mac. It also ensures that these packages run smoothly by providing sample code."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#are-you-a-novice-or-an-expert",
    "href": "posts/2023-10-25-Setup-Mac/index.html#are-you-a-novice-or-an-expert",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Are you a novice or an expert?",
    "text": "Are you a novice or an expert?\nIf you’re new to the setup of environments and software packages, consider watching the video version in conjunction with the comprehensive written instructions below.\nFor those experienced in setting up environments, the concise text-based instructions should suffice."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#video-guide-available",
    "href": "posts/2023-10-25-Setup-Mac/index.html#video-guide-available",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Video guide available:",
    "text": "Video guide available:\nYou can access a detailed step-by-step video guide of the content covered in this article on YouTube."
  },
  {
    "objectID": "posts/2023-10-25-Setup-Mac/index.html#lets-start",
    "href": "posts/2023-10-25-Setup-Mac/index.html#lets-start",
    "title": "Setup TensorFlow, PyTorch, and Hugging Face Transformer on Mac in 5 Minutes",
    "section": "Let’s Start 🏁",
    "text": "Let’s Start 🏁\nI will detail each step so a beginner can also be transition their journey to data science smoothly.\n\n1 - Install Homebrew\nVisit - Homebrew\nCopy and Paste the command present on the website or use the below command in the Terminal:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n\n2 - Install Anaconda or MiniConda\nI prefer Anaconda and I will be using it for further process.\nVisit - Anaconda Downloads\nVisit - Installation Guide\nFor Command Line -\nbash ~/Downloads/Anaconda\\ 2023.09\\ MacOSX-arm64.sh\nSet Conda Base to Activate by default -\nconda config --set auto_activate_base True"
  },
  {
    "objectID": "projects/2023-10-25-kbp-nse/index.html",
    "href": "projects/2023-10-25-kbp-nse/index.html",
    "title": "kbp-nse",
    "section": "",
    "text": "CitationBibTeX citation:@online{prasanna koppolu2023,\n  author = {Prasanna Koppolu, Bhanu},\n  title = {Kbp-Nse},\n  date = {2023-10-25},\n  url = {https://bhanuprasanna527.github.io/projects/2023-10-25-kbp-nse/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nPrasanna Koppolu, Bhanu. 2023. “Kbp-Nse.” October 25, 2023.\nhttps://bhanuprasanna527.github.io/projects/2023-10-25-kbp-nse/."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nkbp-nse\n\n\n\n\n\n\n\nProjects\n\n\nPython\n\n\nFinance\n\n\n\n\nMy personal Stock Data Retriever Project kbp-nse.\n\n\n\n\n\n\nOct 25, 2023\n\n\nBhanu Prasanna Koppolu\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Code\nimport numpy as np\nimport pandas as pd"
  },
  {
    "objectID": "about.html#this-is-a-python-test",
    "href": "about.html#this-is-a-python-test",
    "title": "About",
    "section": "",
    "text": "Code\nimport numpy as np\nimport pandas as pd"
  },
  {
    "objectID": "notes/2023-11-04-NeetCode_150/index.html",
    "href": "notes/2023-11-04-NeetCode_150/index.html",
    "title": "NeetCode 150",
    "section": "",
    "text": "The first approach is the idea popped from my mind when I looked at the problem."
  },
  {
    "objectID": "notes/2023-11-04-NeetCode_150/index.html#contains-duplicate---217---leetcode---easy---array-hashing",
    "href": "notes/2023-11-04-NeetCode_150/index.html#contains-duplicate---217---leetcode---easy---array-hashing",
    "title": "NeetCode 150",
    "section": "Contains Duplicate - 217 - LeetCode - Easy - Array & Hashing",
    "text": "Contains Duplicate - 217 - LeetCode - Easy - Array & Hashing\n\nApproach - 1\nThe First Approach that came to my mind was to write a Nested For Loop to check if it Contains Duplicate.\nclass Solution {\npublic:\n    bool containsDuplicate(vector&lt;int&gt;& nums) {\n        for (auto i = nums.begin(); i != nums.end(); i++) {\n            for (auto j = i + 1; j != nums.end(); j++) {\n                if (*i == *j) return true;\n            }\n        }\n\n        return false;\n    }\n};\n\nOutput\nThe First Approach has Time Complexity of O(\\(N^{2}\\)) and Space Complexity of O(1).\nTime Limit Exceeded\n70 / 75 testcases passed\n\n\n\nApproach - 2\nAnother Approach to this problem is using Sorting then Checking if it Contains Duplicate.\nclass Solution {\npublic:\n    bool containsDuplicate(vector&lt;int&gt;& nums) {\n        sort(nums.begin(), nums.end());\n\n        for (int i = 0; i &lt; nums.size() - 1; i++) {\n            if (nums[i] == nums[i+1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nOutput\nThe Second Approach has Time Complexity of O(N log(N)) and Space Complexity of O(1).\nAccepted\n\n\n\nApproach - 3\nUsing unordered_set to check if it Contains Duplicate. The Time Complexity for Basic operations in unordered_set is O(1) and for set it is O(log(N)).\nclass Solution {\npublic:\n    bool containsDuplicate(vector&lt;int&gt;& nums) {\n        unordered_set&lt;int&gt; us;\n\n        for (auto i = nums.begin(); i != nums.end(); i++) {\n            if (us.find(*i) != us.end()) {\n                return true;\n            }\n            us.insert(*i);\n        }\n\n        return false;\n    }\n};\n\nOutput\nThe Third Approach has Time Complexity of O(N) and Space Complexity of O(N). The optimal solution.\nAccepted"
  },
  {
    "objectID": "notes/2023-11-04-NeetCode_150/index.html#valid-anagram---242---leetcode---easy---array-hashing",
    "href": "notes/2023-11-04-NeetCode_150/index.html#valid-anagram---242---leetcode---easy---array-hashing",
    "title": "NeetCode 150",
    "section": "Valid Anagram - 242 - LeetCode - Easy - Array & Hashing",
    "text": "Valid Anagram - 242 - LeetCode - Easy - Array & Hashing\n\nApproach - 1\nSort the characters of the string of t and s then check if both are same or not.\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n\n        if (s == t) {\n            return true;\n        }\n        return false;\n    }\n};\n\nOutput\nThe First Approach has Time Complexity of O(N log(N)) and Space Complexity of O(1).\nAccepted\n\n\n\nApproach - 2\nUsing unordered_map which has principles derived from Hash Map. So basic operations are O(1).\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        \n        if (s.size() != t.size()) {\n            return false;\n        }\n\n        unordered_map&lt;char, int&gt; ums;\n        unordered_map&lt;char, int&gt; umt;\n\n        for (int i = 0; i &lt; s.size(); i++) {\n            ums[s[i]]++;\n            umt[t[i]]++;\n        }\n\n        for (int i = 0; i &lt; s.size(); i++) {\n            if (ums[s[i]] != umt[s[i]]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\nOutput\nThe Second Approach has Time Complexity of O(S + T) and Space Complexity of O(S + T).\nAccepted"
  },
  {
    "objectID": "notes/2023-11-04-NeetCode_150/index.html#two-sum---1---leetcode---easy---array-hashing",
    "href": "notes/2023-11-04-NeetCode_150/index.html#two-sum---1---leetcode---easy---array-hashing",
    "title": "NeetCode 150",
    "section": "Two Sum - 1 - LeetCode - Easy - Array & Hashing",
    "text": "Two Sum - 1 - LeetCode - Easy - Array & Hashing\n\nApproach - 1\nThe general approach to this problem is Brute Force Approach.\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {\n        int l = nums.size();\n        \n        for (int i = 0; i &lt; l; i++) {\n            for (int j = 0; j &lt; l && i != j; j ++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n\n        return {};\n    }\n};\n\nOutput\nThe First Approach has Time Complexity of O(\\(N^{2}\\)) and Space Complexity of O(1).\nAccepted\n\n\n\nApproach - 2\nUsing unordered_map which has principles derived from Hash Map. So basic operations are O(1).\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;& nums, int target) {\n        unordered_map&lt;int, int&gt; um;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (auto search = um.find(target - nums[i]); search != um.end()) {\n                return {search-&gt;second, i};\n            }\n\n            um[nums[i]] = i;\n        }\n\n        return {};\n    }\n};\n\nOutput\nThe Second Approach has Time Complexity of O(N) and Space Complexity of O(N).\nAccepted"
  },
  {
    "objectID": "notes/2023-11-04-NeetCode_150/index.html#group-anagrams---49---leetcode---medium---array-hashing",
    "href": "notes/2023-11-04-NeetCode_150/index.html#group-anagrams---49---leetcode---medium---array-hashing",
    "title": "NeetCode 150",
    "section": "Group Anagrams - 49 - LeetCode - Medium - Array & Hashing",
    "text": "Group Anagrams - 49 - LeetCode - Medium - Array & Hashing\n\nApproach - 1\nSorting and Matching Strings.\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;& strs) {\n        vector&lt;string&gt; st = strs;\n        vector&lt;vector&lt;string&gt;&gt; fs;\n        unordered_set&lt;int&gt; us;\n        \n        for (int i = 0; i &lt; st.size(); i++) {\n            sort(st[i].begin(), st[i].end());\n        }\n\n        for (int i = 0; i &lt; st.size(); i++) {\n            vector&lt;string&gt; vs;\n\n            for (int j = i; j &lt; st.size(); j++) {\n                if (us.find(j) == us.end()) {\n                    if (st[i] == st[j]) {\n                        vs.push_back(strs[j]);\n                        us.insert(j);\n                    }\n                }\n            }\n            if (vs.size() != 0) {\n                fs.push_back(vs);\n            }\n        }\n\n        return fs;\n    }\n};\n\nOutput\nThe First Approach has Time Complexity of O(mn log(n)) and Space Complexity of O(n).\nAccepted\n\n\n\nApproach - 2\nUsed Hash Map to reduce the Time Complexity.\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;& strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; m;\n\n        for (int i = 0; i &lt; strs.size(); i++) {\n            string key = getkey(strs[i]);\n            m[key].push_back(strs[i]);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; fs;\n\n        for (auto i = m.begin(); i != m.end(); i++) {\n            fs.push_back(i-&gt;second);\n        }\n\n        return fs;\n    }\nprivate:\n    string getkey (string val) {\n        string s = \"\";\n        vector&lt;int&gt; c(26);\n\n        for (int i = 0; i &lt; val.size(); i++) {\n            c[val[i] - 'a'] += 1;\n        }\n\n        for (int i = 0; i &lt; 26; i++) {\n            s = s + to_string(c[i]) + '#';\n        }\n\n        return s;\n    }\n};\n\nOutput\nThe Second Approach has Time Complexity of O(mn) and Space Complexity of O(mn).\nAccepted"
  }
]